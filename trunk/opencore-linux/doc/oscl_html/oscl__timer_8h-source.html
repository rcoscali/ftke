<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>oscl_timer.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>oscl_timer.h</h1><a href="oscl__timer_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="preprocessor">#ifndef OSCL_TIMER_H_INCLUDED</span>
00002 <span class="preprocessor"></span><span class="preprocessor">#define OSCL_TIMER_H_INCLUDED</span>
00003 <span class="preprocessor"></span>
00004 <span class="preprocessor">#ifndef OSCL_BASE_H_INCLUDED</span>
00005 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__base_8h.html">oscl_base.h</a>"</span>
00006 <span class="preprocessor">#endif</span>
00007 <span class="preprocessor"></span>
00008 <span class="preprocessor">#ifndef OSCLCONFIG_UTIL_H_INCLUDED</span>
00009 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="osclconfig__util_8h.html">osclconfig_util.h</a>"</span>
00010 <span class="preprocessor">#endif</span>
00011 <span class="preprocessor"></span>
00012 <span class="preprocessor">#ifndef OSCL_VECTOR_H_INCLUDED</span>
00013 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__vector_8h.html">oscl_vector.h</a>"</span>
00014 <span class="preprocessor">#endif</span>
00015 <span class="preprocessor"></span>
00016 <span class="preprocessor">#ifndef OSCL_TICKCOUNT_H_INCLUDED</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__tickcount_8h.html">oscl_tickcount.h</a>"</span>
00018 <span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span>
00020 <span class="preprocessor">#ifndef OSCL_RAND_H_INCLUDED</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__rand_8h.html">oscl_rand.h</a>"</span>
00022 <span class="preprocessor">#endif</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#ifndef OSCL_SCHEDULER_AO_H_INCLUDED</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__scheduler__ao_8h.html">oscl_scheduler_ao.h</a>"</span>
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 
<a name="l00032"></a><a class="code" href="classOsclTimerObserver.html">00032</a> <span class="keyword">class </span><a class="code" href="classOsclTimerObserver.html">OsclTimerObserver</a>
00033 {
00034     <span class="keyword">public</span>:
00043         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classOsclTimerObserver.html#a0">TimeoutOccurred</a>(int32 timerID, int32 timeoutInfo) = 0;
00044 
<a name="l00045"></a><a class="code" href="classOsclTimerObserver.html#a1">00045</a>         <span class="keyword">virtual</span> <a class="code" href="classOsclTimerObserver.html#a1">~OsclTimerObserver</a>() {}
00046 };
00047 
00053 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
00054 <span class="keyword">class </span><a class="code" href="classOsclTimer.html">OsclTimer</a> ;
00055 
<a name="l00056"></a><a class="code" href="classCallbackTimerObserver.html">00056</a> <span class="keyword">class </span><a class="code" href="classCallbackTimerObserver.html">CallbackTimerObserver</a>
00057 {
00058     <span class="keyword">public</span>:
00059         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classCallbackTimerObserver.html#a0">TimerBaseElapsed</a>() = 0;
<a name="l00060"></a><a class="code" href="classCallbackTimerObserver.html#a1">00060</a>         <span class="keyword">virtual</span> <a class="code" href="classCallbackTimerObserver.html#a1">~CallbackTimerObserver</a>() {}
00061 };
00062 
00063 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00064"></a><a class="code" href="classCallbackTimer.html">00064</a> <span class="keyword">class </span><a class="code" href="classCallbackTimer.html">CallbackTimer</a>: <span class="keyword">public</span> <a class="code" href="classOsclTimerObject.html">OsclTimerObject</a>
00065 {
00066     <span class="keyword">public</span>:
<a name="l00067"></a><a class="code" href="classCallbackTimer.html#a0">00067</a>         <a class="code" href="classCallbackTimer.html#a0">CallbackTimer</a>(<a class="code" href="classCallbackTimerObserver.html">CallbackTimerObserver</a>&amp; aContainer, <span class="keyword">const</span> <span class="keywordtype">char</span> *name, int32 aPriority = <a class="code" href="classOsclActiveObject.html#s5s2">OsclActiveObject::EPriorityNominal</a>)
00068                 : <a class="code" href="classOsclTimerObject.html">OsclTimerObject</a>(aPriority, name)
00069         {
00070             iContainer = &amp;aContainer;
00071             <a class="code" href="classOsclTimerObject.html#a2">AddToScheduler</a>();
00072         }
<a name="l00073"></a><a class="code" href="classCallbackTimer.html#a1">00073</a>         <a class="code" href="classCallbackTimer.html#a1">~CallbackTimer</a>()
00074         {
00075             <a class="code" href="classOsclTimerObject.html#a3">RemoveFromScheduler</a>();
00076         }
<a name="l00077"></a><a class="code" href="classCallbackTimer.html#a2">00077</a>         <span class="keywordtype">void</span> <a class="code" href="classCallbackTimer.html#a2">Run</a>()
00078         {
00079             <span class="keywordflow">if</span> (<a class="code" href="classOsclTimerObject.html#a10">Status</a>() == <a class="code" href="group__osclproc.html#a0">OSCL_REQUEST_ERR_NONE</a>)
00080                 iContainer-&gt;<a class="code" href="classCallbackTimerObserver.html#a0">TimerBaseElapsed</a>();
00081         }
00082     <span class="keyword">private</span>:
00083         <a class="code" href="classCallbackTimerObserver.html">CallbackTimerObserver</a> *iContainer;
00084 };
00085 
00086 
00087 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00088"></a><a class="code" href="classOsclTimer.html">00088</a> <span class="keyword">class </span><a class="code" href="classOsclTimer.html">OsclTimer</a> : <span class="keyword">public</span> <a class="code" href="classCallbackTimerObserver.html">CallbackTimerObserver</a>
00089 {
00090     <span class="keyword">public</span>:
00091 
<a name="l00092"></a><a class="code" href="classOsclTimer.html#s0">00092</a>         <span class="keyword">typedef</span> <a class="code" href="classCallbackTimer.html">CallbackTimer&lt;Alloc&gt;</a> <a class="code" href="classCallbackTimer.html">callback_timer_type</a>;
00093 
00100         <a class="code" href="classOsclTimer.html#a0">OsclTimer</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, uint32 frequency = 1, int32 priority = <a class="code" href="classOsclActiveObject.html#s5s2">OsclActiveObject::EPriorityNominal</a>);
00101         <span class="keyword">virtual</span> <a class="code" href="classOsclTimer.html#a1">~OsclTimer</a>();
00102 
<a name="l00109"></a><a class="code" href="classOsclTimer.html#a2">00109</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a2">SetObserver</a>(<a class="code" href="classOsclTimerObserver.html">OsclTimerObserver</a> *obs)
00110         {
00111             iObserver = obs;
00112         }
00119         <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a3">SetFrequency</a>(uint32 frequency);
00120 
00127         <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a4">SetExactFrequency</a>(uint32 frequency);
00128 
00142         <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a5">Request</a>(int32 timerID, int32 timeoutInfo, int32 cycles, <a class="code" href="classOsclTimerObserver.html">OsclTimerObserver</a> *obs = 0, <span class="keywordtype">bool</span> recurring = 0);
00151         <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a6">Cancel</a>(int32 timerID, int32 timeoutInfo = -1);
00155         <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a7">Clear</a>();
00156 
00157     <span class="keyword">private</span>:
00158         <span class="comment">//Note: the timer needs to be a new'd object so that</span>
00159         <span class="comment">//the CBase construction zeros the memory.</span>
00160         callback_timer_type *iTimer;
00161 
00162         <span class="keyword">typedef</span> <span class="keyword">struct  </span>_TimerEntry
00163         {
00164             int32 iCounter ;
00165             int32 iTimerID ;
00166             int32 iParam ;
00167             <a class="code" href="classOsclTimerObserver.html">OsclTimerObserver</a> *iObserver;
00168             <span class="keywordtype">bool</span> iRecurring;
00169             int32 iOrigCounter;
00170         } TimerEntry;
00171 
00172         <span class="keyword">typedef</span> TimerEntry                    entry_type;
00173         <span class="keyword">typedef</span> <a class="code" href="classOscl__Vector.html">Oscl_Vector&lt;entry_type*, Alloc&gt;</a> entries_type;
00174         <span class="keyword">typedef</span> <span class="keyword">typename</span> entries_type::iterator entries_type_iterator;
00175 
00176         <a class="code" href="classOsclTimerObserver.html">OsclTimerObserver</a> *iObserver;
00177         entries_type iEntries;
00178         entries_type iEntriesWaitingToAdd;
00179         entries_type iEntriesWaitingToCancel;
00180         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;entry_type, Alloc&gt;</a> iEntryAllocator;
00181 
00182         <span class="keywordtype">bool</span> iInCallback;
00183 
00184         uint32 iCyclePeriod;
00185         uint32 iTickCountPeriod;
00186         uint32 iExpectedTimeout;
00187 
00188     <span class="keyword">protected</span>:
00189         <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#b0">TimerBaseElapsed</a>();
<a name="l00190"></a><a class="code" href="classOsclTimer.html#l0">00190</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classCallbackTimer.html">CallbackTimer</a>&lt;Alloc&gt;;
00191 };
00192 
00193 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00194"></a><a class="code" href="classOsclTimer.html#a0">00194</a> <a class="code" href="classOsclTimer.html#a0">OsclTimer&lt;Alloc&gt;::OsclTimer</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, uint32 frequency, int32 priority) :
00195         iObserver(0)
00196         , iInCallback(false)
00197         , iTickCountPeriod(0)
00198         , iExpectedTimeout(0)
00199 {
00200     <span class="comment">//use the allocator with placement 'new'</span>
00201     Alloc alloc;
00202     iTimer = <a class="code" href="group__osclmemory.html#a53">OSCL_PLACEMENT_NEW</a>(alloc.ALLOCATE(<span class="keyword">sizeof</span>(<a class="code" href="classCallbackTimer.html">CallbackTimer&lt;Alloc&gt;</a>)), <a class="code" href="classCallbackTimer.html">CallbackTimer&lt;Alloc&gt;</a>(*<span class="keyword">this</span>, name, priority));
00203     <a class="code" href="classOsclTimer.html#a3">SetFrequency</a>(frequency);
00204 }
00205 
00206 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00207"></a><a class="code" href="classOsclTimer.html#a1">00207</a> <a class="code" href="classOsclTimer.html#a1">OsclTimer&lt;Alloc&gt;::~OsclTimer</a>()
00208 {
00209     <span class="comment">// Make sure we're cancelled</span>
00210     <span class="keywordflow">if</span> (iTimer)
00211         iTimer-&gt;<a class="code" href="classOsclTimerObject.html#a8">Cancel</a>();
00212     <span class="keywordflow">if</span> (iTimer)
00213     {
00214         iTimer-&gt;OSCL_TEMPLATED_DESTRUCTOR_CALL(<a class="code" href="classCallbackTimer.html">callback_timer_type</a>, <a class="code" href="classCallbackTimer.html">CallbackTimer</a>);
00215         Alloc alloc;
00216         alloc.deallocate(iTimer);
00217     }
00218     iTimer = <a class="code" href="group__osclbase.html#a81">NULL</a>;
00219 
00220     <span class="keywordflow">for</span> (entries_type_iterator it = iEntries.<a class="code" href="classOscl__Vector.html#a17">begin</a>(); it != iEntries.<a class="code" href="classOscl__Vector.html#a18">end</a>(); it++)
00221     {
00222         iEntryAllocator.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>(*it);
00223     }
00224 }
00225 
00226 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00227"></a><a class="code" href="classOsclTimer.html#a3">00227</a> <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a3">OsclTimer&lt;Alloc&gt;::SetFrequency</a>(uint32 frequency)
00228 {
00229     <span class="comment">// timer takes microseconds</span>
00230     iCyclePeriod = 1000000 / frequency;
00231     <span class="comment">// get tick count period</span>
00232     iTickCountPeriod = <a class="code" href="classOsclTickCount.html#d2">OsclTickCount::TickCountPeriod</a>();
00233 }
00234 
00235 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00236"></a><a class="code" href="classOsclTimer.html#a4">00236</a> <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a4">OsclTimer&lt;Alloc&gt;::SetExactFrequency</a>(uint32 frequency)
00237 {
00238     <span class="comment">// timer takes microseconds</span>
00239     iCyclePeriod = frequency;
00240     <span class="comment">// get tick count period</span>
00241     iTickCountPeriod = <a class="code" href="classOsclTickCount.html#d2">OsclTickCount::TickCountPeriod</a>();
00242 }
00243 
00244 <span class="comment">// Request a timer</span>
00245 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00246"></a><a class="code" href="classOsclTimer.html#a5">00246</a> <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a5">OsclTimer&lt;Alloc&gt;::Request</a>(int32 timerID, int32 param, int32 cycles, <a class="code" href="classOsclTimerObserver.html">OsclTimerObserver</a> *obs, <span class="keywordtype">bool</span> recurring)
00247 {
00248 
00249     <span class="comment">// add to list of timers</span>
00250     entry_type *entry = iEntryAllocator.ALLOCATE(1);
00251     entry-&gt;iTimerID = timerID;
00252     entry-&gt;iParam = param;
00253     entry-&gt;iCounter = cycles;
00254     entry-&gt;iObserver = obs;
00255     entry-&gt;iRecurring = recurring;
00256     entry-&gt;iOrigCounter = entry-&gt;iCounter;
00257 
00258     <span class="comment">// if the request is called inside of a callback, then we must add it later</span>
00259     <span class="keywordflow">if</span> (iInCallback)
00260     {
00261         iEntriesWaitingToAdd.<a class="code" href="classOscl__Vector.html#a5">push_back</a>(entry);
00262         <span class="keywordflow">return</span>;
00263     }
00264 
00265     iEntries.<a class="code" href="classOscl__Vector.html#a5">push_back</a>(entry);
00266 
00267     <span class="keywordflow">if</span> (iTimer)
00268     {
00269         iTimer-&gt;<a class="code" href="classOsclTimerObject.html#a5">RunIfNotReady</a>(iCyclePeriod);
00270     }
00271 
00272     <span class="keywordflow">if</span> (iExpectedTimeout == 0)
00273     {
00274         iExpectedTimeout = (<a class="code" href="classOsclTickCount.html#d0">OsclTickCount::TickCount</a>() * iTickCountPeriod) + iCyclePeriod;
00275     }
00276 }
00277 
00278 <span class="comment">// Cancel a timer</span>
00279 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00280"></a><a class="code" href="classOsclTimer.html#a6">00280</a> <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a6">OsclTimer&lt;Alloc&gt;::Cancel</a>(int32 timerID, int32 param)
00281 {
00282 
00283     <span class="keywordflow">if</span> (iInCallback)
00284     {
00285         <span class="comment">// add to list of timers</span>
00286         entry_type *entry = iEntryAllocator.ALLOCATE(1);
00287         entry-&gt;iTimerID = timerID;
00288         entry-&gt;iParam = param;
00289 
00290         iEntriesWaitingToCancel.<a class="code" href="classOscl__Vector.html#a5">push_back</a>(entry);
00291         <span class="keywordflow">return</span>;
00292     }
00293 
00294     <span class="comment">// remove from list of timers</span>
00295     <span class="keywordflow">for</span> (entries_type_iterator it = iEntries.<a class="code" href="classOscl__Vector.html#a17">begin</a>(); it != iEntries.<a class="code" href="classOscl__Vector.html#a18">end</a>(); it++)
00296     {
00297         <span class="keywordflow">if</span> ((*it)-&gt;iTimerID == timerID)
00298         {
00299             <span class="comment">// make sure the param matches unless it is not specified (-1)</span>
00300             <span class="keywordflow">if</span> ((*it)-&gt;iParam == param || param == -1)
00301             {
00302                 iEntryAllocator.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>(*it);
00303                 iEntries.<a class="code" href="classOscl__Vector.html#a19">erase</a>(it);
00304                 <span class="keywordflow">return</span>;
00305             }
00306         }
00307     }
00308 }
00309 
00310 <span class="comment">// Clear all waiting timers</span>
00311 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00312"></a><a class="code" href="classOsclTimer.html#a7">00312</a> <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#a7">OsclTimer&lt;Alloc&gt;::Clear</a>()
00313 {
00314     <span class="keywordflow">for</span> (entries_type_iterator it = iEntries.<a class="code" href="classOscl__Vector.html#a17">begin</a>(); it != iEntries.<a class="code" href="classOscl__Vector.html#a18">end</a>(); it++)
00315     {
00316         iEntryAllocator.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>(*it);
00317     }
00318     iEntries.<a class="code" href="classOscl__Vector.html#a15">clear</a>();
00319 }
00320 
00321 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00322"></a><a class="code" href="classOsclTimer.html#b0">00322</a> <span class="keywordtype">void</span> <a class="code" href="classOsclTimer.html#b0">OsclTimer&lt;Alloc&gt;::TimerBaseElapsed</a>()
00323 {
00324     uint8 expiredFound = 0;
00325 
00326     {
00327         <span class="comment">// call all whose timers have expired</span>
00328         <span class="keywordflow">for</span> (entries_type_iterator it = iEntries.<a class="code" href="classOscl__Vector.html#a17">begin</a>(); it != iEntries.<a class="code" href="classOscl__Vector.html#a18">end</a>(); it++)
00329         {
00330             entry_type *entry = (*it);
00331             <span class="keywordflow">if</span> (--(entry-&gt;iCounter) &lt;= 0)
00332             {
00333                 <span class="keywordflow">if</span> (!entry-&gt;iRecurring) expiredFound = 1;
00334                 <span class="keywordflow">if</span> (entry-&gt;iRecurring) entry-&gt;iCounter = entry-&gt;iOrigCounter;
00335 
00336                 <span class="comment">// use local observer if it exists, otherwise use global observer</span>
00337                 <a class="code" href="classOsclTimerObserver.html">OsclTimerObserver</a> *obs = (entry-&gt;iObserver ? entry-&gt;iObserver : iObserver);
00338                 <span class="keywordflow">if</span> (obs)
00339                 {
00340                     iInCallback = <span class="keyword">true</span>;
00341                     obs-&gt;<a class="code" href="classOsclTimerObserver.html#a0">TimeoutOccurred</a>(entry-&gt;iTimerID, entry-&gt;iParam);
00342                     iInCallback = <span class="keyword">false</span>;
00343                 }
00344             }
00345         }
00346     }
00347 
00348     <span class="comment">// remove from list all whose timers have expired</span>
00349     <span class="keywordflow">while</span> (expiredFound)
00350     {
00351         expiredFound = 0;
00352         <span class="keywordflow">for</span> (entries_type_iterator it = iEntries.<a class="code" href="classOscl__Vector.html#a17">begin</a>(); it != iEntries.<a class="code" href="classOscl__Vector.html#a18">end</a>(); it++)
00353         {
00354             entry_type *entry = (*it);
00355             <span class="keywordflow">if</span> (entry-&gt;iCounter &lt;= 0)
00356             {
00357                 expiredFound = 1;
00358                 iEntryAllocator.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>(entry);
00359                 iEntries.<a class="code" href="classOscl__Vector.html#a19">erase</a>(it);
00360                 <span class="keywordflow">break</span>;
00361             }
00362         }
00363     }
00364 
00365     {
00366         <span class="comment">// if any timers were cancelled in the callback, process them now</span>
00367         <span class="keywordflow">for</span> (entries_type_iterator it = iEntriesWaitingToCancel.<a class="code" href="classOscl__Vector.html#a17">begin</a>(); it != iEntriesWaitingToCancel.<a class="code" href="classOscl__Vector.html#a18">end</a>(); it++)
00368         {
00369             entry_type *entry = (*it);
00370             <a class="code" href="classOsclTimer.html#a6">Cancel</a>(entry-&gt;iTimerID, entry-&gt;iParam);
00371             iEntryAllocator.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>(entry);
00372         }
00373         iEntriesWaitingToCancel.<a class="code" href="classOscl__Vector.html#a15">clear</a>();
00374     }
00375 
00376     {
00377         <span class="comment">// if any timers were requested in the callback, process them now</span>
00378         <span class="keywordflow">for</span> (entries_type_iterator it = iEntriesWaitingToAdd.<a class="code" href="classOscl__Vector.html#a17">begin</a>(); it != iEntriesWaitingToAdd.<a class="code" href="classOscl__Vector.html#a18">end</a>(); it++)
00379         {
00380             entry_type *entry = (*it);
00381             <a class="code" href="classOsclTimer.html#a5">Request</a>(entry-&gt;iTimerID, entry-&gt;iParam, entry-&gt;iCounter, entry-&gt;iObserver);
00382             iEntryAllocator.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>(entry);
00383         }
00384         iEntriesWaitingToAdd.<a class="code" href="classOscl__Vector.html#a15">clear</a>();
00385     }
00386 
00387     <span class="keywordflow">if</span> (!iEntries.<a class="code" href="classOscl__Vector__Base.html#a2">empty</a>())
00388     {
00389         <span class="comment">// adjust for the jitter</span>
00390         uint32 time = <a class="code" href="classOsclTickCount.html#d0">OsclTickCount::TickCount</a>() * iTickCountPeriod;
00391         int32 jitter = time - iExpectedTimeout;
00392         int32 waitperiod = iCyclePeriod - jitter;
00393 
00394         <span class="comment">// currently there is some problem on the phone if we send</span>
00395         <span class="comment">// in real-time rather than with a slower (growing delay) H.223 mux output</span>
00396         <span class="comment">// if jitter is too large in either direction, start over</span>
00397         <span class="keywordflow">if</span> ((uint)<a class="code" href="group__osclbase.html#a93">OSCL_ABS</a>(jitter) &gt; iCyclePeriod)
00398         {
00399             iExpectedTimeout = time;
00400         }
00401         <span class="keywordflow">else</span>
00402         {
00403             iExpectedTimeout += iCyclePeriod;
00404         }
00405 
00406         waitperiod = <a class="code" href="group__osclbase.html#a92">OSCL_MAX</a>(waitperiod, 0);
00407 
00408         <span class="keywordflow">if</span> (iTimer)
00409         {
00410             iTimer-&gt;<a class="code" href="classOsclTimerObject.html#a5">RunIfNotReady</a>(waitperiod);
00411         }
00412     }
00413     <span class="keywordflow">else</span>
00414     {
00415         iExpectedTimeout = 0;
00416     }
00417 }
00418 
00419 
00420 
00421 <span class="preprocessor">#endif</span>
</pre></div><hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: OPENCORE_20090310 </small>
</small></address>
</body>
</html>
