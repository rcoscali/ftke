<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>oscl_media_data.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>oscl_media_data.h</h1><a href="oscl__media__data_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">// -*- c++ -*-</span>
00002 <span class="comment">// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</span>
00003 
00004 <span class="comment">//               O S C L _ M E D I A _ D A T A</span>
00005 
00006 <span class="comment">// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</span>
00007 
00018 <span class="preprocessor">#ifndef OSCL_MEDIA_DATA_H</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define OSCL_MEDIA_DATA_H</span>
00020 <span class="preprocessor"></span>
00021 <span class="preprocessor">#ifndef OSCL_BASE_H_INCLUDED</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__base_8h.html">oscl_base.h</a>"</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#ifndef OSCL_MEM_BASIC_FUNCTIONS_H_INCLUDED</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__mem__basic__functions_8h.html">oscl_mem_basic_functions.h</a>"</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor"></span>
00029 <span class="preprocessor">#ifndef OSCL_MEDIA_STATUS_H_INCLUDED</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__media__status_8h.html">oscl_media_status.h</a>"</span>
00031 <span class="preprocessor">#endif</span>
00032 <span class="preprocessor"></span>
<a name="l00033"></a><a class="code" href="group__osclutil.html#a1">00033</a> <span class="keyword">typedef</span> void (*<a class="code" href="group__osclutil.html#a1">BufferFreeFuncPtr</a>)(<span class="keywordtype">void</span> *);
00034 
<a name="l00035"></a><a class="code" href="group__osclutil.html#a2">00035</a> <span class="keyword">typedef</span> uint32 <a class="code" href="group__osclutil.html#a2">MediaTimestamp</a>;
00036 
<a name="l00037"></a><a class="code" href="classMemAllocator.html">00037</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span><a class="code" href="classMemAllocator.html">MemAllocator</a>
00038 {
00039     <span class="keyword">public</span>:
<a name="l00040"></a><a class="code" href="classMemAllocator.html#s0">00040</a>         <span class="keyword">typedef</span> T* <a class="code" href="classMemAllocator.html#s0">pointer</a>;
00041         <span class="comment">//  virtual pointer allocate(size_t size, void *hint = 0) = 0;</span>
00042         <span class="keyword">virtual</span> <a class="code" href="classMemAllocator.html#s0">pointer</a> <a class="code" href="classMemAllocator.html#a0">allocate</a>(<span class="keywordtype">void</span> * hint = 0, <span class="keyword">const</span> <span class="keywordtype">int</span> num_reserved_frags = 1) = 0;
00043         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMemAllocator.html#a1">deallocate</a>(<a class="code" href="classMemAllocator.html#s0">pointer</a> p) = 0;
<a name="l00044"></a><a class="code" href="classMemAllocator.html#a2">00044</a>         <span class="keyword">virtual</span> <a class="code" href="classMemAllocator.html#a2">~MemAllocator</a>() {}
00045 };
00046 
00047 <span class="keyword">class </span><a class="code" href="classBufferState.html">BufferState</a>;
00048 <span class="comment">/* Buffer referee (how about the "whistle blower" ?*/</span>
<a name="l00049"></a><a class="code" href="classBufferMgr.html">00049</a> <span class="keyword">class </span><a class="code" href="classBufferMgr.html">BufferMgr</a>
00050 {
00051     <span class="keyword">public</span>:
00052         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBufferMgr.html#a0">BufferReleased</a>(<span class="keywordtype">void</span>* ptr, <a class="code" href="classBufferState.html">BufferState</a>* state = <a class="code" href="group__osclbase.html#a81">NULL</a>) = 0;
<a name="l00053"></a><a class="code" href="classBufferMgr.html#a1">00053</a>         <span class="keyword">virtual</span> <a class="code" href="classBufferMgr.html#a1">~BufferMgr</a>() {}
00054 };
00055 
00056 
<a name="l00057"></a><a class="code" href="classBufferState.html">00057</a> <span class="keyword">class </span><a class="code" href="classBufferState.html">BufferState</a>
00058 {
00059     <span class="keyword">public</span>:
<a name="l00060"></a><a class="code" href="classBufferState.html#a0">00060</a>         <a class="code" href="classBufferState.html#a0">BufferState</a>(<a class="code" href="group__osclutil.html#a1">BufferFreeFuncPtr</a> the_free_function, <span class="keywordtype">void</span> *bufptr = 0) :
00061                 refcount(0), ptr(bufptr), free_function(the_free_function), buf_mgr(0) {};
00062 
<a name="l00063"></a><a class="code" href="classBufferState.html#a1">00063</a>         <a class="code" href="classBufferState.html#a0">BufferState</a>(<a class="code" href="classBufferMgr.html">BufferMgr</a>* the_buf_mgr = 0, <span class="keywordtype">void</span> *bufptr = 0) :
00064                 refcount(0), ptr(bufptr), free_function(0), buf_mgr(the_buf_mgr) {};
00065 
<a name="l00066"></a><a class="code" href="classBufferState.html#a2">00066</a>         <span class="keywordtype">void</span> <a class="code" href="classBufferState.html#a2">increment_refcnt</a>()
00067         {
00068             ++refcount;
00069         };
<a name="l00070"></a><a class="code" href="classBufferState.html#a3">00070</a>         <span class="keywordtype">void</span> <a class="code" href="classBufferState.html#a3">decrement_refcnt</a>()
00071         {
00072             <span class="keywordflow">if</span> (!(--refcount))
00073             {
00074                 <span class="keywordflow">if</span> (buf_mgr) buf_mgr-&gt;<a class="code" href="classBufferMgr.html#a0">BufferReleased</a>(ptr, <span class="keyword">this</span>);
00075                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (free_function)
00076                 {
00077                     free_function(ptr);
00078                     ptr = 0;
00079                 }
00080             }
00081         };
00082 
<a name="l00083"></a><a class="code" href="classBufferState.html#a4">00083</a>         <span class="keywordtype">void</span> <a class="code" href="classBufferState.html#a4">bind</a>(<span class="keywordtype">void</span> *in_ptr, <a class="code" href="group__osclutil.html#a1">BufferFreeFuncPtr</a> in_free_function)
00084         {
00085             refcount = 0;
00086             ptr = in_ptr, free_function = in_free_function;
00087 
00088         };
<a name="l00089"></a><a class="code" href="classBufferState.html#a5">00089</a>         <span class="keywordtype">void</span> <a class="code" href="classBufferState.html#a4">bind</a>(<span class="keywordtype">void</span> *in_ptr, <a class="code" href="classBufferMgr.html">BufferMgr</a>* in_buf_mgr)
00090         {
00091             refcount = 0;
00092             ptr = in_ptr, buf_mgr = in_buf_mgr;
00093         };
00094 
<a name="l00095"></a><a class="code" href="classBufferState.html#a6">00095</a>         <span class="keywordtype">void</span> *<a class="code" href="classBufferState.html#a6">get_ptr</a>()
00096         {
00097             <span class="keywordflow">return</span> ptr;
00098         };
<a name="l00099"></a><a class="code" href="classBufferState.html#a7">00099</a>         int32 <a class="code" href="classBufferState.html#a7">get_refcount</a>()
00100         {
00101             <span class="keywordflow">return</span> refcount;
00102         };
00103 
<a name="l00104"></a><a class="code" href="classBufferState.html#a8">00104</a>         <a class="code" href="group__osclutil.html#a1">BufferFreeFuncPtr</a> <a class="code" href="classBufferState.html#a8">get_free_function</a>()
00105         {
00106             <span class="keywordflow">return</span> free_function;
00107         };
<a name="l00108"></a><a class="code" href="classBufferState.html#a9">00108</a>         <a class="code" href="classBufferMgr.html">BufferMgr</a>* <a class="code" href="classBufferState.html#a9">get_buf_mgr</a>()
00109         {
00110             <span class="keywordflow">return</span> buf_mgr;
00111         };
00112 
<a name="l00113"></a><a class="code" href="classBufferState.html#a10">00113</a>         <span class="keywordtype">void</span> <a class="code" href="classBufferState.html#a10">reset</a>()
00114         {
00115             refcount = 0;
00116             ptr = 0;
00117         };
00118 
00119     <span class="keyword">private</span>:
00120         int32 refcount;
00121         <span class="keywordtype">void</span> *ptr;
00122         <a class="code" href="group__osclutil.html#a1">BufferFreeFuncPtr</a> free_function; <span class="comment">// called to free the buffer</span>
00123         <a class="code" href="classBufferMgr.html">BufferMgr</a>* buf_mgr; <span class="comment">// called to free the buffer</span>
00124 };
00125 
00126 
00127 <span class="comment">// BufferFragment is a special case of a memory</span>
00128 <span class="comment">// fragment since it refers to fragments of a reference</span>
00129 <span class="comment">// counted memory.  The name is used to make this explicit.</span>
<a name="l00130"></a><a class="code" href="classBufferFragment.html">00130</a> <span class="keyword">class </span><a class="code" href="classBufferFragment.html">BufferFragment</a> : <span class="keyword">public</span> <a class="code" href="structOsclMemoryFragment.html">OsclMemoryFragment</a> {};
00131 
00132 
<a name="l00133"></a><a class="code" href="classBufFragGroup.html">00133</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> ChainClass, u<span class="keywordtype">int</span>32 max_frags&gt; <span class="keyword">class </span><a class="code" href="classBufFragGroup.html">BufFragGroup</a>
00134 {
00135     <span class="keyword">public</span>:
00136 
00137 
<a name="l00138"></a><a class="code" href="classBufFragGroup.html#a0">00138</a>         <a class="code" href="classBufFragGroup.html#a0">BufFragGroup</a>(): <a class="code" href="classBufFragGroup.html#n2">next</a>(0), <a class="code" href="classBufFragGroup.html#n3">num_fragments</a>(0), <a class="code" href="classBufFragGroup.html#n4">length</a>(0)
00139         {
00140             <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<a class="code" href="classBufFragGroup.html#n0">fragments</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="classBufFragGroup.html#n0">fragments</a>));
00141             <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<a class="code" href="classBufFragGroup.html#n1">buffer_states</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="classBufFragGroup.html#n1">buffer_states</a>));
00142         };
00143 
<a name="l00144"></a><a class="code" href="classBufFragGroup.html#a1">00144</a>         <span class="keyword">virtual</span> <a class="code" href="classBufFragGroup.html#a1">~BufFragGroup</a>() {}
00145 
<a name="l00146"></a><a class="code" href="classBufFragGroup.html#a2">00146</a>         int32 <a class="code" href="classBufFragGroup.html#a2">GetMaxFrags</a>()<span class="keyword"> const</span>
00147 <span class="keyword">        </span>{
00148             <span class="keywordflow">return</span> max_frags;
00149         };
<a name="l00150"></a><a class="code" href="classBufFragGroup.html#a3">00150</a>         int32 <a class="code" href="classBufFragGroup.html#a3">GetNumFrags</a>()<span class="keyword"> const</span>
00151 <span class="keyword">        </span>{
00152             <span class="keywordflow">return</span> <a class="code" href="classBufFragGroup.html#n3">num_fragments</a>;
00153         };
<a name="l00154"></a><a class="code" href="classBufFragGroup.html#a4">00154</a>         uint32 <a class="code" href="classBufFragGroup.html#a4">GetLength</a>()<span class="keyword"> const</span>
00155 <span class="keyword">        </span>{
00156             <span class="keywordflow">return</span> <a class="code" href="classBufFragGroup.html#n4">length</a>;
00157         };
00158 
00159         <a class="code" href="classBufferFragment.html">BufferFragment</a> * <a class="code" href="group__osclutil.html#a48">GetFragment</a>(<span class="keyword">const</span> int32 idx);
00160 
00161         <a class="code" href="classBufferState.html">BufferState</a> * <a class="code" href="group__osclutil.html#a49">GetBufferState</a>(<span class="keyword">const</span> int32 idx);
00162 
<a name="l00163"></a><a class="code" href="classBufFragGroup.html#a7">00163</a>         <span class="keywordtype">void</span> <a class="code" href="classBufFragGroup.html#a7">AppendNext</a>(ChainClass* next_ptr)
00164         {
00165             <a class="code" href="classBufFragGroup.html#n2">next</a> = next_ptr;
00166         };
<a name="l00167"></a><a class="code" href="classBufFragGroup.html#a8">00167</a>         ChainClass* <a class="code" href="classBufFragGroup.html#a8">GetNext</a>()<span class="keyword"> const</span>
00168 <span class="keyword">        </span>{
00169             <span class="keywordflow">return</span> <a class="code" href="classBufFragGroup.html#n2">next</a>;
00170         };
00171 
00172         <span class="comment">// make fragment array accessible to allow usage within socket</span>
00173         <span class="comment">// send functions.</span>
00174 
00175     <span class="keyword">protected</span>:
00176 
00177 
00178         <span class="comment">// BufferFragment * GetFragment(const uint32 idx) const;</span>
00179 
00180 
00181 
<a name="l00182"></a><a class="code" href="classBufFragGroup.html#b0">00182</a>         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classBufFragGroup.html#b0">Clear</a>()
00183         {
00184             <span class="keywordflow">for</span> (<a class="code" href="group__osclbase.html#a27">uint</a> ii = 0 ; ii &lt; <a class="code" href="classBufFragGroup.html#n3">num_fragments</a>; ++ii)
00185             {
00186                 <span class="keywordflow">if</span> (<a class="code" href="classBufFragGroup.html#n1">buffer_states</a>[ii])
00187                 {
00188                     <a class="code" href="classBufFragGroup.html#n1">buffer_states</a>[ii]-&gt;<a class="code" href="classBufferState.html#a3">decrement_refcnt</a>();
00189                 }
00190             }
00191             <a class="code" href="classBufFragGroup.html#n3">num_fragments</a> = <a class="code" href="classBufFragGroup.html#n4">length</a> = 0;
00192             <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<a class="code" href="classBufFragGroup.html#n1">buffer_states</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="classBufFragGroup.html#n1">buffer_states</a>));
00193             <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<a class="code" href="classBufFragGroup.html#n0">fragments</a>, 0, <span class="keyword">sizeof</span>(<a class="code" href="classBufFragGroup.html#n0">fragments</a>));
00194         };
00195 
<a name="l00196"></a><a class="code" href="classBufFragGroup.html#b1">00196</a>         <a class="code" href="classBufFragStatusClass.html#s8">BufFragStatusClass::status_t</a> <a class="code" href="classBufFragGroup.html#b1">AddFragment</a>(<span class="keyword">const</span> <a class="code" href="classBufferFragment.html">BufferFragment</a>&amp; frag, <a class="code" href="classBufferState.html">BufferState</a>* in_buffer_state,
00197                 int32 location_offset = max_frags)
00198         {
00199             <span class="keywordflow">if</span> (<a class="code" href="classBufFragGroup.html#n3">num_fragments</a> &gt; max_frags)
00200             {
00201                 <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s1">BufFragStatusClass::TOO_MANY_FRAGS</a>;
00202             }
00203             <span class="keywordflow">if</span> (frag.<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a> == <a class="code" href="group__osclbase.html#a81">NULL</a>)
00204             {
00205                 <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s3">BufFragStatusClass::EMPTY_FRAGMENT</a>;
00206             }
00207 
00208             <span class="keywordflow">if</span> (location_offset &gt;= 0 &amp;&amp; location_offset &lt; (int32) <a class="code" href="classBufFragGroup.html#n3">num_fragments</a>)
00209             {
00210                 <span class="keywordflow">if</span> (<a class="code" href="classBufFragGroup.html#n0">fragments</a>[location_offset].<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a>)
00211                 {
00212                     <span class="comment">// make room for the new fragment</span>
00213                     <a class="code" href="group__osclmemory.html#a12">oscl_memmove</a>(<a class="code" href="classBufFragGroup.html#n0">fragments</a> + location_offset + 1, <a class="code" href="classBufFragGroup.html#n0">fragments</a> + location_offset,
00214                                  (<a class="code" href="classBufFragGroup.html#n3">num_fragments</a> - location_offset)*<span class="keyword">sizeof</span>(<a class="code" href="classBufferFragment.html">BufferFragment</a>));
00215                     <a class="code" href="group__osclmemory.html#a12">oscl_memmove</a>(<a class="code" href="classBufFragGroup.html#n1">buffer_states</a> + location_offset + 1, <a class="code" href="classBufFragGroup.html#n1">buffer_states</a> + location_offset,
00216                                  (<a class="code" href="classBufFragGroup.html#n3">num_fragments</a> - location_offset)*<span class="keyword">sizeof</span>(<a class="code" href="classBufferState.html">BufferState</a>*));
00217                     ++<a class="code" href="classBufFragGroup.html#n3">num_fragments</a>; <span class="comment">/* increment the number of fragments if a move</span>
00218 <span class="comment">                          * is necessary.  If the location was empty, then</span>
00219 <span class="comment">                          * has already been reserved and counted.</span>
00220 <span class="comment">                          */</span>
00221                 }
00222                 <a class="code" href="classBufFragGroup.html#n0">fragments</a>[location_offset] = frag;
00223                 <a class="code" href="classBufFragGroup.html#n1">buffer_states</a>[location_offset] = in_buffer_state;
00224                 <span class="keywordflow">if</span> (in_buffer_state) in_buffer_state-&gt;<a class="code" href="classBufferState.html#a2">increment_refcnt</a>();
00225                 <a class="code" href="classBufFragGroup.html#n4">length</a> += frag.<a class="code" href="structOsclMemoryFragment.html#m0">len</a>;
00226                 <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s0">BufFragStatusClass::BFG_SUCCESS</a>;
00227             }
00228 
00229             <span class="comment">// append the new fragment to the end</span>
00230             <a class="code" href="classBufFragGroup.html#n0">fragments</a>[<a class="code" href="classBufFragGroup.html#n3">num_fragments</a>] = frag;
00231             <a class="code" href="classBufFragGroup.html#n1">buffer_states</a>[<a class="code" href="classBufFragGroup.html#n3">num_fragments</a>++] = in_buffer_state;
00232             <a class="code" href="classBufFragGroup.html#n4">length</a> += frag.<a class="code" href="structOsclMemoryFragment.html#m0">len</a>;
00233             <span class="keywordflow">if</span> (in_buffer_state) in_buffer_state-&gt;<a class="code" href="classBufferState.html#a2">increment_refcnt</a>();
00234             <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s0">BufFragStatusClass::BFG_SUCCESS</a>;
00235         };
00236 
<a name="l00237"></a><a class="code" href="classBufFragGroup.html#n0">00237</a>         <a class="code" href="classBufferFragment.html">BufferFragment</a> <a class="code" href="classBufFragGroup.html#n0">fragments</a>[max_frags];
<a name="l00238"></a><a class="code" href="classBufFragGroup.html#n1">00238</a>         <a class="code" href="classBufferState.html">BufferState</a>* <a class="code" href="classBufFragGroup.html#n1">buffer_states</a>[max_frags];
<a name="l00239"></a><a class="code" href="classBufFragGroup.html#n2">00239</a>         ChainClass* <a class="code" href="classBufFragGroup.html#n2">next</a>;
<a name="l00240"></a><a class="code" href="classBufFragGroup.html#n3">00240</a>         uint32 <a class="code" href="classBufFragGroup.html#n3">num_fragments</a>;
<a name="l00241"></a><a class="code" href="classBufFragGroup.html#n4">00241</a>         uint32 <a class="code" href="classBufFragGroup.html#n4">length</a>;
00242 };
00243 
<a name="l00244"></a><a class="code" href="classBufFragGroup.html#a48">00244</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> ChainClass, u<span class="keywordtype">int</span>32 max_frags&gt; <span class="keyword">inline</span> <a class="code" href="classBufferFragment.html">BufferFragment</a> *  <a class="code" href="group__osclutil.html#a48">BufFragGroup&lt;ChainClass, max_frags&gt; :: GetFragment</a>(<span class="keyword">const</span> int32 idx)
00245 {
00246     <span class="keywordflow">if</span> (idx &lt; (int)num_fragments &amp;&amp; idx &gt;= 0)
00247     {
00248         <span class="keywordflow">return</span> &amp; <a class="code" href="classBufFragGroup.html#n0">fragments</a>[idx];
00249     }
00250     <span class="keywordflow">else</span>
00251     {
00252         <span class="keywordflow">return</span> <a class="code" href="group__osclbase.html#a81">NULL</a>;
00253     }
00254 }
00255 
<a name="l00256"></a><a class="code" href="classBufFragGroup.html#a49">00256</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> ChainClass, u<span class="keywordtype">int</span>32 max_frags&gt; <span class="keyword">inline</span> <a class="code" href="classBufferState.html">BufferState</a> *  <a class="code" href="group__osclutil.html#a49">BufFragGroup&lt;ChainClass, max_frags&gt; :: GetBufferState</a>(<span class="keyword">const</span> int32 idx)
00257 {
00258     <span class="keywordflow">if</span> (idx &lt; (int)num_fragments &amp;&amp; idx &gt;= 0)
00259     {
00260         <span class="keywordflow">return</span>  <a class="code" href="classBufFragGroup.html#n1">buffer_states</a>[idx];
00261     }
00262     <span class="keywordflow">else</span>
00263     {
00264         <span class="keywordflow">return</span> <a class="code" href="group__osclbase.html#a81">NULL</a>;
00265     }
00266 }
00267 
00268 
<a name="l00269"></a><a class="code" href="classMediaData.html">00269</a> <span class="keyword">template</span> &lt;<span class="keyword">class</span> ChainClass, u<span class="keywordtype">int</span>32 max_frags, u<span class="keywordtype">int</span>32 local_bufsize&gt; <span class="keyword">class </span><a class="code" href="classMediaData.html">MediaData</a> :
00270             <span class="keyword">public</span> <a class="code" href="classBufFragGroup.html">BufFragGroup</a>&lt;ChainClass, max_frags&gt;
00271 {
00272 
00273     <span class="keyword">public</span>:
<a name="l00274"></a><a class="code" href="classMediaData.html#a0">00274</a>         <a class="code" href="classMediaData.html#a0">MediaData</a>(): <a class="code" href="classMediaData.html#n0">timestamp</a>(0), <a class="code" href="classMediaData.html#n2">available_localbuf</a>(local_bufsize), <a class="code" href="classMediaData.html#n3">num_reserved_fragments</a>(0) {};
00275 
<a name="l00276"></a><a class="code" href="classMediaData.html#a1">00276</a>         <span class="keyword">virtual</span> <a class="code" href="classMediaData.html#a1">~MediaData</a>() {}
00277 
<a name="l00278"></a><a class="code" href="classMediaData.html#a2">00278</a>         uint32 <a class="code" href="classMediaData.html#a2">GetLocalBufsize</a>()<span class="keyword"> const</span>
00279 <span class="keyword">        </span>{
00280             <span class="keywordflow">return</span> local_bufsize;
00281         };
<a name="l00282"></a><a class="code" href="classMediaData.html#a3">00282</a>         <a class="code" href="group__osclutil.html#a2">MediaTimestamp</a> <a class="code" href="classMediaData.html#a3">GetTimestamp</a>()<span class="keyword"> const</span>
00283 <span class="keyword">        </span>{
00284             <span class="keywordflow">return</span> <a class="code" href="classMediaData.html#n0">timestamp</a>;
00285         };
<a name="l00286"></a><a class="code" href="classMediaData.html#a4">00286</a>         <span class="keywordtype">void</span> <a class="code" href="classMediaData.html#a4">SetTimestamp</a>(<a class="code" href="group__osclutil.html#a2">MediaTimestamp</a> in_timestamp)
00287         {
00288             <a class="code" href="classMediaData.html#n0">timestamp</a> = in_timestamp;
00289         };
<a name="l00290"></a><a class="code" href="classMediaData.html#a5">00290</a>         uint32 <a class="code" href="classMediaData.html#a5">GetAvailableBufferSize</a>()<span class="keyword"> const</span>
00291 <span class="keyword">        </span>{
00292             <span class="keywordflow">return</span> <a class="code" href="classMediaData.html#n2">available_localbuf</a>;
00293         };
00294 
00295 
00296 
00297         <span class="comment">// The input should be initialized so that the fragment length is the</span>
00298         <span class="comment">// request size.  The returned value will have a non-NULL pointer if the</span>
00299         <span class="comment">// request could be fulfilled.</span>
<a name="l00300"></a><a class="code" href="classMediaData.html#a6">00300</a>         <a class="code" href="classBufFragStatusClass.html#s8">MediaStatusClass::status_t</a> <a class="code" href="classMediaData.html#a6">GetLocalFragment</a>(<a class="code" href="classBufferFragment.html">BufferFragment</a>&amp; fragment)
00301         {
00302             <span class="keywordflow">if</span> (fragment.<a class="code" href="structOsclMemoryFragment.html#m0">len</a> &gt; <a class="code" href="classMediaData.html#n2">available_localbuf</a>)
00303             {
00304                 fragment.<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a> = <a class="code" href="group__osclbase.html#a81">NULL</a>;
00305                 fragment.<a class="code" href="structOsclMemoryFragment.html#m0">len</a> = <a class="code" href="classMediaData.html#n2">available_localbuf</a>;
00306                 <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s2">MediaStatusClass::NOT_ENOUGH_SPACE</a>;
00307             }
00308 
00309             fragment.<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a> = <a class="code" href="classMediaData.html#n1">localbuf</a> + (local_bufsize - <a class="code" href="classMediaData.html#n2">available_localbuf</a>);
00310             <a class="code" href="classMediaData.html#n2">available_localbuf</a> -= fragment.<a class="code" href="structOsclMemoryFragment.html#m0">len</a>;
00311             <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s0">MediaStatusClass::BFG_SUCCESS</a>;
00312         };
00313 
<a name="l00314"></a><a class="code" href="classMediaData.html#a7">00314</a>         <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMediaData.html#a7">Clear</a>()
00315         {
00316             <span class="keywordflow">for</span> (<a class="code" href="group__osclbase.html#a27">uint</a> ii = 0 ; ii &lt; this-&gt;<a class="code" href="classBufFragGroup.html#n3">num_fragments</a>; ++ii)
00317             {
00318                 <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classBufFragGroup.html#n1">buffer_states</a>[ii])
00319                 {
00320                     this-&gt;<a class="code" href="classBufFragGroup.html#n1">buffer_states</a>[ii]-&gt;<a class="code" href="classBufferState.html#a3">decrement_refcnt</a>();
00321                 }
00322             }
00323             this-&gt;<a class="code" href="classBufFragGroup.html#n3">num_fragments</a> = 0;
00324             this-&gt;<a class="code" href="classBufFragGroup.html#n4">length</a> = 0;
00325             <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(this-&gt;buffer_states, 0, <span class="keyword">sizeof</span>(this-&gt;buffer_states));
00326             <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(this-&gt;fragments, 0, <span class="keyword">sizeof</span>(this-&gt;fragments));
00327             this-&gt;<a class="code" href="classMediaData.html#n2">available_localbuf</a> = local_bufsize;
00328         };
00329 
00330 
<a name="l00331"></a><a class="code" href="classMediaData.html#a8">00331</a>         <span class="keywordtype">bool</span> <a class="code" href="classMediaData.html#a8">IsLocalData</a>(<span class="keyword">const</span> <a class="code" href="structOsclMemoryFragment.html">OsclMemoryFragment</a>&amp; frag)<span class="keyword"> const</span>
00332 <span class="keyword">        </span>{
00333             <span class="keywordflow">if</span> (frag.<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a> == <a class="code" href="group__osclbase.html#a81">NULL</a>)
00334                 <span class="keywordflow">return</span> <span class="keyword">true</span>;
00335             <span class="keywordflow">if</span> ((uint8 *)frag.<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a> &gt;= <a class="code" href="classMediaData.html#n1">localbuf</a>)
00336             {
00337                 <span class="keywordflow">if</span> (((uint8 *)frag.<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a>) + frag.<a class="code" href="structOsclMemoryFragment.html#m0">len</a> &lt; <a class="code" href="classMediaData.html#n1">localbuf</a> + local_bufsize)
00338                 {
00339                     <span class="keywordflow">return</span> <span class="keyword">true</span>;
00340                 }
00341                 <span class="keywordflow">return</span> <span class="keyword">false</span>;
00342             }
00343             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00344         }
00345 
<a name="l00346"></a><a class="code" href="classMediaData.html#a9">00346</a>         <span class="keywordtype">int</span> <a class="code" href="classMediaData.html#a9">GetMediaSize</a>()<span class="keyword"> const</span>
00347 <span class="keyword">        </span>{
00348             <span class="keywordtype">int</span> num_reserved = 0;
00349             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; <a class="code" href="classMediaData.html#n3">num_reserved_fragments</a>; ii++)
00350                 num_reserved += this-&gt;<a class="code" href="classBufFragGroup.html#n0">fragments</a>[ii].<a class="code" href="structOsclMemoryFragment.html#m0">len</a>;
00351 
00352             <span class="keywordflow">return</span> (this-&gt;<a class="code" href="classBufFragGroup.html#n4">length</a> - num_reserved);
00353         }
00354 
<a name="l00355"></a><a class="code" href="classMediaData.html#a10">00355</a>         <a class="code" href="classBufferFragment.html">BufferFragment</a> * <a class="code" href="classMediaData.html#a10">GetMediaFragment</a>(<span class="keyword">const</span> uint32 idx)
00356         {
00357             uint32 tmp = idx + this-&gt;<a class="code" href="classMediaData.html#n3">num_reserved_fragments</a>;
00358             <span class="keywordflow">if</span> (tmp &gt; this-&gt;<a class="code" href="classBufFragGroup.html#n3">num_fragments</a>)
00359             {
00360                 <span class="keywordflow">return</span> <a class="code" href="group__osclbase.html#a81">NULL</a>;
00361             }
00362             <span class="keywordflow">else</span>
00363             {
00364                 <span class="keywordflow">return</span> &amp; this-&gt;<a class="code" href="classBufFragGroup.html#n0">fragments</a>[tmp];
00365             }
00366         }
00367 
<a name="l00368"></a><a class="code" href="classMediaData.html#a11">00368</a>         uint32 <a class="code" href="classMediaData.html#a11">GetNumMediaFrags</a>(<span class="keyword">const</span> uint32 idx)<span class="keyword"> const</span>
00369 <span class="keyword">        </span>{
00370             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classBufFragGroup.html#n3">num_fragments</a> &gt;= this-&gt;<a class="code" href="classMediaData.html#n3">num_reserved_fragments</a>)
00371                 <span class="keywordflow">return</span> this-&gt;<a class="code" href="classBufFragGroup.html#n3">num_fragments</a> - this-&gt;<a class="code" href="classMediaData.html#n3">num_reserved_fragments</a>;
00372             <span class="keywordflow">else</span> <span class="keywordflow">return</span> 0;
00373         }
00374 
00375     <span class="keyword">protected</span>:
00376         <span class="comment">// This function copies the fragment data to the local buffer</span>
<a name="l00377"></a><a class="code" href="classMediaData.html#b0">00377</a>         <a class="code" href="classBufFragStatusClass.html#s8">MediaStatusClass::status_t</a> <a class="code" href="classMediaData.html#b0">AddLocalFragment</a>(<span class="keyword">const</span> <a class="code" href="classBufferFragment.html">BufferFragment</a>&amp; frag,
00378                 int32 location_offset)
00379         {
00380 
00381             <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classBufFragGroup.html#n3">num_fragments</a> &gt; max_frags)
00382             {
00383                 <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s1">MediaStatusClass::TOO_MANY_FRAGS</a>;
00384             }
00385 
00386             <span class="keywordflow">if</span> (frag.<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a> == <a class="code" href="group__osclbase.html#a81">NULL</a> || frag.<a class="code" href="structOsclMemoryFragment.html#m0">len</a> == 0)
00387             {
00388                 <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s3">MediaStatusClass::EMPTY_FRAGMENT</a>;
00389             }
00390 
00391             <span class="comment">// see if there is enough room in the local buffer</span>
00392             <span class="keywordflow">if</span> (frag.<a class="code" href="structOsclMemoryFragment.html#m0">len</a> &gt; <a class="code" href="classMediaData.html#n2">available_localbuf</a>)
00393             {
00394                 <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s2">MediaStatusClass::NOT_ENOUGH_SPACE</a>;
00395             }
00396 
00397             <span class="comment">// get the fragment</span>
00398             <a class="code" href="classBufferFragment.html">BufferFragment</a> local_fragment;
00399             local_fragment.<a class="code" href="structOsclMemoryFragment.html#m0">len</a> = frag.<a class="code" href="structOsclMemoryFragment.html#m0">len</a>;
00400             local_fragment.<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a> = <a class="code" href="classMediaData.html#n1">localbuf</a> + (local_bufsize - <a class="code" href="classMediaData.html#n2">available_localbuf</a>);
00401             <a class="code" href="classMediaData.html#n2">available_localbuf</a> -= frag.<a class="code" href="structOsclMemoryFragment.html#m0">len</a>;
00402             this-&gt;<a class="code" href="classBufFragGroup.html#n4">length</a> += frag.<a class="code" href="structOsclMemoryFragment.html#m0">len</a>;
00403 
00404             <a class="code" href="group__osclmemory.html#a11">oscl_memcpy</a>(local_fragment.<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a>, frag.<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a>, frag.<a class="code" href="structOsclMemoryFragment.html#m0">len</a>*<span class="keyword">sizeof</span>(uint8));
00405 
00406             <span class="keywordflow">if</span> (location_offset &gt;= 0 &amp;&amp; location_offset &lt; (int32) this-&gt;<a class="code" href="classBufFragGroup.html#n3">num_fragments</a>)
00407             {
00408                 <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classBufFragGroup.html#n0">fragments</a>[location_offset].<a class="code" href="structOsclMemoryFragment.html#m1">ptr</a>)
00409                 {
00410                     <span class="comment">// make room for the new fragment</span>
00411                     <a class="code" href="group__osclmemory.html#a12">oscl_memmove</a>(this-&gt;fragments + location_offset + 1, this-&gt;fragments + location_offset,
00412                                  (this-&gt;num_fragments - location_offset)*<span class="keyword">sizeof</span>(<a class="code" href="classBufferFragment.html">BufferFragment</a>));
00413                     <a class="code" href="group__osclmemory.html#a12">oscl_memmove</a>(this-&gt;buffer_states + location_offset + 1, this-&gt;buffer_states + location_offset,
00414                                  (this-&gt;num_fragments - location_offset)*<span class="keyword">sizeof</span>(<a class="code" href="classBufferState.html">BufferState</a>*));
00415                     ++this-&gt;<a class="code" href="classBufFragGroup.html#n3">num_fragments</a>; <span class="comment">/* increment the number of fragments if a move</span>
00416 <span class="comment">                                * is necessary.  If the location was empty, then</span>
00417 <span class="comment">                                * has already been reserved and counted.</span>
00418 <span class="comment">                                */</span>
00419                 }
00420                 this-&gt;<a class="code" href="classBufFragGroup.html#n0">fragments</a>[location_offset] = local_fragment;
00421                 this-&gt;<a class="code" href="classBufFragGroup.html#n1">buffer_states</a>[location_offset] = <a class="code" href="group__osclbase.html#a81">NULL</a>;
00422                 <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s0">MediaStatusClass::BFG_SUCCESS</a>;
00423             }
00424 
00425             <span class="comment">// append the new fragment to the end</span>
00426             this-&gt;<a class="code" href="classBufFragGroup.html#n0">fragments</a>[this-&gt;<a class="code" href="classBufFragGroup.html#n3">num_fragments</a>] = local_fragment;
00427             this-&gt;<a class="code" href="classBufFragGroup.html#n1">buffer_states</a>[this-&gt;<a class="code" href="classBufFragGroup.html#n3">num_fragments</a>++] = <a class="code" href="group__osclbase.html#a81">NULL</a>;
00428             <span class="keywordflow">return</span> <a class="code" href="classBufFragStatusClass.html#s8s0">MediaStatusClass::BFG_SUCCESS</a>;
00429         };
00430 
<a name="l00431"></a><a class="code" href="classMediaData.html#n0">00431</a>         <a class="code" href="group__osclutil.html#a2">MediaTimestamp</a> <a class="code" href="classMediaData.html#n0">timestamp</a>;
<a name="l00432"></a><a class="code" href="classMediaData.html#n1">00432</a>         uint8 <a class="code" href="classMediaData.html#n1">localbuf</a>[local_bufsize];
<a name="l00433"></a><a class="code" href="classMediaData.html#n2">00433</a>         uint32 <a class="code" href="classMediaData.html#n2">available_localbuf</a>;
00434 
<a name="l00435"></a><a class="code" href="classMediaData.html#n3">00435</a>         <span class="keywordtype">int</span> <a class="code" href="classMediaData.html#n3">num_reserved_fragments</a>;
00436 };
00437 
00438 <span class="preprocessor">#endif</span>
00439 <span class="preprocessor"></span>
</pre></div><hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: OPENCORE_20090310 </small>
</small></address>
</body>
</html>
