<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OsclUDPSocket class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>OsclUDPSocket Class Reference<br>
<small>
[<a class="el" href="group__osclio.html">OSCL IO</a>]</small>
</h1><code>#include &lt;<a class="el" href="oscl__socket_8h-source.html">oscl_socket.h</a>&gt;</code>
<p>
<p>Inheritance diagram for OsclUDPSocket:
<p><center><img src="classOsclUDPSocket.png" usemap="#OsclUDPSocket_map" border="0" alt=""></center>
<map name="OsclUDPSocket_map">
<area href="classHeapBase.html" alt="HeapBase" shape="rect" coords="0,56,103,80">
<area href="class__OsclHeapBase.html" alt="_OsclHeapBase" shape="rect" coords="0,0,103,24">
</map>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a0">~OsclUDPSocket</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF int32&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a1">Close</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF int32&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a2">Bind</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF int32&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a3">Join</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a>&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a4">BindAsync</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress, int32 aTimeoutMsec=(-1))</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a5">CancelBind</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF uint8 *&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a6">GetRecvData</a> (int32 *aLength)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF uint8 *&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a7">GetSendData</a> (int32 *aLength)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a>&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a8">SendTo</a> (const uint8 *aPtr, uint32 aLen, <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress, int32 aTimeoutMsec=-1)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a9">CancelSendTo</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a>&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a10">RecvFrom</a> (uint8 *aPtr, uint32 aMaxLen, <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress, int32 aTimeoutMsec=-1, uint32 aMultiRecvLimit=0, <a class="el" href="classOscl__Vector.html">Oscl_Vector</a>&lt; uint32, <a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a> &gt; *aPacketLen=NULL, <a class="el" href="classOscl__Vector.html">Oscl_Vector</a>&lt; <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a>, <a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a> &gt; *aPacketSource=NULL)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a11">CancelRecvFrom</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF int32&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#a12">SetRecvBufferSize</a> (uint32 size)</td></tr>
<tr><td colspan=2><br><h2>Static Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF OsclUDPSocket *&nbsp;</td><td valign=bottom><a class="el" href="classOsclUDPSocket.html#d0">NewL</a> (<a class="el" href="classOscl__DefAlloc.html">Oscl_DefAlloc</a> &amp;alloc, <a class="el" href="classOsclSocketServ.html">OsclSocketServ</a> &amp;aServ, <a class="el" href="classOsclSocketObserver.html">OsclSocketObserver</a> *aObserver, uint32 aId)</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The UDP Socket class 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="OsclUDPSocket::~OsclUDPSocket"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF OsclUDPSocket::~OsclUDPSocket </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor. The object must be deleted using the same allocator used in the NewL call.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a2" doxytag="OsclUDPSocket::Bind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF int32 OsclUDPSocket::Bind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aAddress</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bind a UDP socket to an address. This is a synchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aAddress:</em>&nbsp;</td><td>
Bind address. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns OsclErrNone for success, or a platform-specific error code. </dl>    </td>
  </tr>
</table>
<a name="a4" doxytag="OsclUDPSocket::BindAsync"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a> OsclUDPSocket::BindAsync </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aAddress</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimeoutMsec</em> = (-1)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bind a UDP socket to an address. This is an asynchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aAddress:</em>&nbsp;</td><td>
Bind address. </td></tr>
<tr><td valign=top><em>aTimeoutMsec:</em>&nbsp;</td><td>
Optional timeout. Use a negative value for infinite wait. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dl>    </td>
  </tr>
</table>
<a name="a5" doxytag="OsclUDPSocket::CancelBind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclUDPSocket::CancelBind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel Bind
<p>
This method will cancel any pending BindAsync operation on the current socket, causing the BindAsync to complete with error EPVSocketCancel. If there is no pending BindAsync operation, this method will have no effect.     </td>
  </tr>
</table>
<a name="a11" doxytag="OsclUDPSocket::CancelRecvFrom"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclUDPSocket::CancelRecvFrom </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel RecvFrom
<p>
This method will cancel any pending RecvFrom operation on the current socket, causing the RecvFrom to complete with error EPVSocketCancel. If there is no pending RecvFrom operation, this method will have no effect.     </td>
  </tr>
</table>
<a name="a9" doxytag="OsclUDPSocket::CancelSendTo"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclUDPSocket::CancelSendTo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel SendTo
<p>
This method will cancel any pending SendTo operation on the current socket, causing the SendTo to complete with error EPVSocketCancel. If there is no pending SendTo operation, this method will have no effect.     </td>
  </tr>
</table>
<a name="a1" doxytag="OsclUDPSocket::Close"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF int32 OsclUDPSocket::Close </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a UDP socket. This is a synchronous method.
<p>
Once it is closed a socket cannot be re-opened. Sockets are automatically closed when they are deleted. This method may be used to see any error code returned from the platform's socket close call. <dl compact><dt><b>Returns: </b></dt><dd>
Returns OsclErrNone for success, or a platform-specific error code. </dl>    </td>
  </tr>
</table>
<a name="a6" doxytag="OsclUDPSocket::GetRecvData"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF uint8* OsclUDPSocket::GetRecvData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aLength</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the received data after a successful RecvFrom operation. This is a synchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aLength:</em>&nbsp;</td><td>
(output) number of bytes of data received. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns pointer to received data, or NULL if none. </dl>    </td>
  </tr>
</table>
<a name="a7" doxytag="OsclUDPSocket::GetSendData"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF uint8* OsclUDPSocket::GetSendData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aLength</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the sent data after a successful SendTo operation. This is a synchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aLength:</em>&nbsp;</td><td>
(output) number of bytes of data sent. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns pointer to sent data, or NULL if none. </dl>    </td>
  </tr>
</table>
<a name="a3" doxytag="OsclUDPSocket::Join"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF int32 OsclUDPSocket::Join </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aAddress</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bind a UDP socket to an address and Join the multicast group. This is a synchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aAddress:</em>&nbsp;</td><td>
Bind address. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns OsclErrNone for success, or a platform-specific error code. May throw an OsclErrNotSupported Exception </dl>    </td>
  </tr>
</table>
<a name="d0" doxytag="OsclUDPSocket::NewL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF OsclUDPSocket* OsclUDPSocket::NewL </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classOscl__DefAlloc.html">Oscl_DefAlloc</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>alloc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOsclSocketServ.html">OsclSocketServ</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aServ</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOsclSocketObserver.html">OsclSocketObserver</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aObserver</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aId</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a UDP Socket. May leave if failure.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>alloc:</em>&nbsp;</td><td>
Memory allocator. </td></tr>
<tr><td valign=top><em>aServ:</em>&nbsp;</td><td>
Socket server. Must be connected. </td></tr>
<tr><td valign=top><em>aObserver:</em>&nbsp;</td><td>
Socket observer. </td></tr>
<tr><td valign=top><em>aId:</em>&nbsp;</td><td>
Socket ID. The caller must assign an ID to each socket. The ID is used to identify the socket in observer callbacks. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns pointer to socket. </dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="OsclUDPSocket::RecvFrom"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a> OsclUDPSocket::RecvFrom </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint8 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aPtr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aMaxLen</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aAddress</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimeoutMsec</em> = -1, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aMultiRecvLimit</em> = 0, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOscl__Vector.html">Oscl_Vector</a>&lt; uint32, <a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a> &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aPacketLen</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOscl__Vector.html">Oscl_Vector</a>&lt; <a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a>, <a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a> &gt; *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aPacketSource</em> = NULL</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive Data. This is an asynchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aPtr:</em>&nbsp;</td><td>
Buffer to receive incoming data </td></tr>
<tr><td valign=top><em>aMaxLen:</em>&nbsp;</td><td>
Length of buffer. </td></tr>
<tr><td valign=top><em>aAddress:</em>&nbsp;</td><td>
(output) Source address. </td></tr>
<tr><td valign=top><em>aTimeoutMsec:</em>&nbsp;</td><td>
Timeout in milliseconds, or (-1) for infinite wait.</td></tr>
<tr><td valign=top><em>aMultiRecvLimit</em>&nbsp;</td><td>
(optional input): Configures multiple packet receive mode. As long as there are packets queued at the socket and at least aMultiRecvLimit bytes are available in the buffer, recvfrom operations will continue. A value of zero disabled multiple packet mode. The individual packet lengths can be retrieved in the aPacketLen parameter; and the individual packet source addresses can be retrieved in the aPacketSource parameter. </td></tr>
<tr><td valign=top><em>aPacketLen:</em>&nbsp;</td><td>
(optional output) a vector of packet lengths, in case multiple packets were received. </td></tr>
<tr><td valign=top><em>aPacketSource:</em>&nbsp;</td><td>
(optional output) a vector of source addresses, in case multiple packets were received.</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dl>    </td>
  </tr>
</table>
<a name="a8" doxytag="OsclUDPSocket::SendTo"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a> OsclUDPSocket::SendTo </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const uint8 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aPtr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLen</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aAddress</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimeoutMsec</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send Data. This is an asynchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aPtr:</em>&nbsp;</td><td>
Data to send. </td></tr>
<tr><td valign=top><em>aLen:</em>&nbsp;</td><td>
Length of data to send. </td></tr>
<tr><td valign=top><em>aAddress:</em>&nbsp;</td><td>
Destination address. </td></tr>
<tr><td valign=top><em>aTimeoutMsec:</em>&nbsp;</td><td>
Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dl>    </td>
  </tr>
</table>
<a name="a12" doxytag="OsclUDPSocket::SetRecvBufferSize"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF int32 OsclUDPSocket::SetRecvBufferSize </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>size</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Set the buffer size of the socket This is a synchronous method. <dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>size:</em>&nbsp;</td><td>
buffer size </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns OsclErrNone for success, or a platform-specific error code. May throw an OsclErrNotSupported Exception. </dl>    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="oscl__socket_8h-source.html">oscl_socket.h</a></ul>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: OPENCORE_20090310 </small>
</small></address>
</body>
</html>
