<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>oscl_mem_audit.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>oscl_mem_audit.h</h1><a href="oscl__mem__audit_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">// -*- c++ -*-</span>
00002 <span class="comment">// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</span>
00003 
00004 <span class="comment">//                   O S C L _ M E M _ A U D I T</span>
00005 
00006 <span class="comment">// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</span>
00007 
00018 <span class="preprocessor">#ifndef OSCL_MEM_AUDIT_H_INCLUDED</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define OSCL_MEM_AUDIT_H_INCLUDED</span>
00020 <span class="preprocessor"></span>
00021 <span class="preprocessor">#ifndef OSCL_LOCK_BASE_H_INCLUDED</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__lock__base_8h.html">oscl_lock_base.h</a>"</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#ifndef OSCL_BASE_ALLOC_H_INCLUDED</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__base__alloc_8h.html">oscl_base_alloc.h</a>"</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor"></span>
00029 <span class="preprocessor">#ifndef OSCL_TAGTREE_H_INCLUDED</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__tagtree_8h.html">oscl_tagtree.h</a>"</span>
00031 <span class="preprocessor">#endif</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#ifndef OSCL_MEM_H_INCLUDED</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__mem_8h.html">oscl_mem.h</a>"</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#ifndef OSCL_MEM_AUTO_PTR_H_INCLUDED</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__mem__auto__ptr_8h.html">oscl_mem_auto_ptr.h</a>"</span>
00039 <span class="preprocessor">#endif</span>
00040 <span class="preprocessor"></span>
<a name="l00041"></a><a class="code" href="oscl__mem__audit_8h.html#a0">00041</a> <span class="preprocessor">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</span>
00042 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="osclconfig__compiler__warnings_8h.html">osclconfig_compiler_warnings.h</a>"</span>
00043 
00044 
00045 <span class="comment">/* DATA TYPES */</span>
<a name="l00046"></a><a class="code" href="structMM__Stats__t.html">00046</a> <span class="keyword">struct </span><a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>
00047 {
<a name="l00048"></a><a class="code" href="structMM__Stats__t.html#m0">00048</a>     uint32  <a class="code" href="structMM__Stats__t.html#m0">numBytes</a>;
<a name="l00049"></a><a class="code" href="structMM__Stats__t.html#m1">00049</a>     uint32  <a class="code" href="structMM__Stats__t.html#m1">peakNumBytes</a>;
<a name="l00050"></a><a class="code" href="structMM__Stats__t.html#m2">00050</a>     uint32  <a class="code" href="structMM__Stats__t.html#m2">numAllocs</a>;
<a name="l00051"></a><a class="code" href="structMM__Stats__t.html#m3">00051</a>     uint32  <a class="code" href="structMM__Stats__t.html#m3">peakNumAllocs</a>;
<a name="l00052"></a><a class="code" href="structMM__Stats__t.html#m4">00052</a>     uint32  <a class="code" href="structMM__Stats__t.html#m4">numAllocFails</a>;
<a name="l00053"></a><a class="code" href="structMM__Stats__t.html#m5">00053</a>     uint32  <a class="code" href="structMM__Stats__t.html#m5">totalNumAllocs</a>;
<a name="l00054"></a><a class="code" href="structMM__Stats__t.html#m6">00054</a>     uint32  <a class="code" href="structMM__Stats__t.html#m6">totalNumBytes</a>;
00055 
<a name="l00056"></a><a class="code" href="structMM__Stats__t.html#a0">00056</a>     <a class="code" href="structMM__Stats__t.html#a0">MM_Stats_t</a>()
00057     {
00058         <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>));
00059     };
<a name="l00060"></a><a class="code" href="structMM__Stats__t.html#a1">00060</a>     <a class="code" href="structMM__Stats__t.html#a0">MM_Stats_t</a>(uint32 sizeIn)
00061     {
00062         <a class="code" href="structMM__Stats__t.html#m0">numBytes</a> = <a class="code" href="structMM__Stats__t.html#m1">peakNumBytes</a> = sizeIn;
00063         <a class="code" href="structMM__Stats__t.html#m3">peakNumAllocs</a> = <a class="code" href="structMM__Stats__t.html#m2">numAllocs</a> = 1;
00064         <a class="code" href="structMM__Stats__t.html#m4">numAllocFails</a> = 0;
00065         <a class="code" href="structMM__Stats__t.html#m5">totalNumAllocs</a> = 1;
00066         <a class="code" href="structMM__Stats__t.html#m6">totalNumBytes</a> = sizeIn;
00067     };
00068 
<a name="l00069"></a><a class="code" href="structMM__Stats__t.html#a2">00069</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__Stats__t.html#a2">reset</a>()
00070     {
00071         <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>));
00072     };
00073 
<a name="l00074"></a><a class="code" href="structMM__Stats__t.html#a3">00074</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__Stats__t.html#a3">update</a>(<span class="keyword">const</span> <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>&amp; delta, <span class="keywordtype">bool</span> add)
00075     {
00076         <span class="keywordflow">if</span> (add)
00077         {
00078             <a class="code" href="structMM__Stats__t.html#m0">numBytes</a> += delta.<a class="code" href="structMM__Stats__t.html#m0">numBytes</a>;
00079             <a class="code" href="structMM__Stats__t.html#m2">numAllocs</a> += delta.<a class="code" href="structMM__Stats__t.html#m2">numAllocs</a>;
00080             <a class="code" href="structMM__Stats__t.html#m4">numAllocFails</a> += delta.<a class="code" href="structMM__Stats__t.html#m4">numAllocFails</a>;
00081             <span class="keywordflow">if</span> (<a class="code" href="structMM__Stats__t.html#m0">numBytes</a> &gt; <a class="code" href="structMM__Stats__t.html#m1">peakNumBytes</a>)
00082             {
00083                 <a class="code" href="structMM__Stats__t.html#m1">peakNumBytes</a> = <a class="code" href="structMM__Stats__t.html#m0">numBytes</a>;
00084             }
00085             <span class="keywordflow">if</span> (<a class="code" href="structMM__Stats__t.html#m2">numAllocs</a> &gt; <a class="code" href="structMM__Stats__t.html#m3">peakNumAllocs</a>)
00086             {
00087                 <a class="code" href="structMM__Stats__t.html#m3">peakNumAllocs</a> = <a class="code" href="structMM__Stats__t.html#m2">numAllocs</a>;
00088             }
00089 
00090             <a class="code" href="structMM__Stats__t.html#m5">totalNumAllocs</a> += delta.<a class="code" href="structMM__Stats__t.html#m2">numAllocs</a>;
00091             <a class="code" href="structMM__Stats__t.html#m6">totalNumBytes</a> += delta.<a class="code" href="structMM__Stats__t.html#m0">numBytes</a>;
00092 
00093         }
00094         <span class="keywordflow">else</span>
00095         {
00096             <a class="code" href="structMM__Stats__t.html#m0">numBytes</a> -= delta.<a class="code" href="structMM__Stats__t.html#m0">numBytes</a>;
00097             <a class="code" href="structMM__Stats__t.html#m2">numAllocs</a> -= delta.<a class="code" href="structMM__Stats__t.html#m2">numAllocs</a>;
00098             <a class="code" href="structMM__Stats__t.html#m4">numAllocFails</a> -= delta.<a class="code" href="structMM__Stats__t.html#m4">numAllocFails</a>;
00099         }
00100     }
00101 
<a name="l00102"></a><a class="code" href="structMM__Stats__t.html#a4">00102</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__Stats__t.html#a4">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> size)
00103     {
00104         <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(size);
00105         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_Stats_t, OsclMemBasicAllocator&gt;</a> statsAlloc;
00106         <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a> *ptr = statsAlloc.<a class="code" href="classOscl__TAlloc.html#a2">allocate</a>(1);
00107         <span class="keywordflow">return</span> ptr;
00108     };
00109 
<a name="l00110"></a><a class="code" href="structMM__Stats__t.html#a5">00110</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__Stats__t.html#a4">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> size, <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>* ptr)
00111     {
00112         <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(size);
00113         <span class="keywordflow">return</span> ptr;
00114     };
00115 
00116 
<a name="l00117"></a><a class="code" href="structMM__Stats__t.html#a6">00117</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__Stats__t.html#a6">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
00118     {
00119         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_Stats_t, OsclMemBasicAllocator&gt;</a> statsAlloc;
00120         statsAlloc.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>((<a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>*)ptr);
00121     };
00122 
00123     <span class="comment">/* won't build on ADS</span>
00124 <span class="comment">    void operator delete(void *ptr, MM_Stats_t* mptr) {</span>
00125 <span class="comment">         OSCL_UNUSED_ARG(ptr);</span>
00126 <span class="comment">         OSCL_UNUSED_ARG(mptr);</span>
00127 <span class="comment">     };</span>
00128 <span class="comment">         */</span>
00129 };
00130 
<a name="l00131"></a><a class="code" href="structMM__FailInsertParam.html">00131</a> <span class="keyword">struct </span><a class="code" href="structMM__FailInsertParam.html">MM_FailInsertParam</a>
00132 {
<a name="l00133"></a><a class="code" href="structMM__FailInsertParam.html#m0">00133</a>     uint32 <a class="code" href="structMM__FailInsertParam.html#m0">nAllocNum</a>;
<a name="l00134"></a><a class="code" href="structMM__FailInsertParam.html#m1">00134</a>     uint16 <a class="code" href="structMM__FailInsertParam.html#m1">xsubi</a>[3];
<a name="l00135"></a><a class="code" href="structMM__FailInsertParam.html#a0">00135</a>     <a class="code" href="structMM__FailInsertParam.html#a0">MM_FailInsertParam</a>(): <a class="code" href="structMM__FailInsertParam.html#m0">nAllocNum</a>(0)
00136     {
00137         <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<a class="code" href="structMM__FailInsertParam.html#m1">xsubi</a>, 0, 3*<span class="keyword">sizeof</span>(<a class="code" href="structMM__FailInsertParam.html#m1">xsubi</a>[0]));
00138     }
00139 
<a name="l00140"></a><a class="code" href="structMM__FailInsertParam.html#a1">00140</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__FailInsertParam.html#a1">reset</a>()
00141     {
00142         <a class="code" href="structMM__FailInsertParam.html#m0">nAllocNum</a> = 0;
00143         <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<a class="code" href="structMM__FailInsertParam.html#m1">xsubi</a>, 0, 3*<span class="keyword">sizeof</span>(<a class="code" href="structMM__FailInsertParam.html#m1">xsubi</a>[0]));
00144     };
00145 
<a name="l00146"></a><a class="code" href="structMM__FailInsertParam.html#a2">00146</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__FailInsertParam.html#a2">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> size)
00147     {
00148         <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(size);
00149         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_FailInsertParam, OsclMemBasicAllocator&gt;</a> failAlloc;
00150         <a class="code" href="structMM__FailInsertParam.html">MM_FailInsertParam</a> *ptr = failAlloc.<a class="code" href="classOscl__TAlloc.html#a2">allocate</a>(1);
00151         <span class="keywordflow">return</span> ptr;
00152     };
00153 
<a name="l00154"></a><a class="code" href="structMM__FailInsertParam.html#a3">00154</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__FailInsertParam.html#a2">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> size, <a class="code" href="structMM__FailInsertParam.html">MM_FailInsertParam</a>* ptr)
00155     {
00156         <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(size);
00157         <span class="keywordflow">return</span> ptr;
00158     };
00159 
00160 
<a name="l00161"></a><a class="code" href="structMM__FailInsertParam.html#a4">00161</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__FailInsertParam.html#a4">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
00162     {
00163         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_FailInsertParam, OsclMemBasicAllocator&gt;</a> failAlloc;
00164         failAlloc.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>((<a class="code" href="structMM__FailInsertParam.html">MM_FailInsertParam</a>*)ptr);
00165     };
00166 
00167     <span class="comment">/* won't build on ADS</span>
00168 <span class="comment">    void operator delete(void *ptr, MM_FailInsertParam* mptr) {</span>
00169 <span class="comment">        OSCL_UNUSED_ARG(ptr);</span>
00170 <span class="comment">        OSCL_UNUSED_ARG(mptr);</span>
00171 <span class="comment">    };*/</span>
00172 };
00173 
<a name="l00174"></a><a class="code" href="classOsclMemStatsNode.html">00174</a> <span class="keyword">class </span><a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>
00175 {
00176     <span class="keyword">public</span>:
00177 
<a name="l00178"></a><a class="code" href="classOsclMemStatsNode.html#m0">00178</a>         <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a> *<a class="code" href="classOsclMemStatsNode.html#m0">pMMStats</a>;
<a name="l00179"></a><a class="code" href="classOsclMemStatsNode.html#m1">00179</a>         <a class="code" href="structMM__FailInsertParam.html">MM_FailInsertParam</a> *<a class="code" href="classOsclMemStatsNode.html#m1">pMMFIParam</a>;
00180 
00181         <span class="comment">/* set a link to map, especially for getting the tags of children nodes */</span>
<a name="l00182"></a><a class="code" href="classOsclMemStatsNode.html#m2">00182</a>         <span class="keywordtype">char</span> *<a class="code" href="classOsclMemStatsNode.html#m2">tag</a>;
00183 
<a name="l00184"></a><a class="code" href="classOsclMemStatsNode.html#a0">00184</a>         <a class="code" href="classOsclMemStatsNode.html#a0">OsclMemStatsNode</a>()
00185         {
00186             pMMStats = <a class="code" href="group__osclbase.html#a81">NULL</a>;
00187             pMMFIParam = <a class="code" href="group__osclbase.html#a81">NULL</a>;
00188             <a class="code" href="classOsclMemStatsNode.html#m2">tag</a> = <a class="code" href="group__osclbase.html#a81">NULL</a>;
00189         }
00190 
<a name="l00191"></a><a class="code" href="classOsclMemStatsNode.html#a1">00191</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemStatsNode.html#a1">reset</a>()
00192         {
00193             <span class="keywordflow">if</span> (pMMStats) pMMStats-&gt;<a class="code" href="structMM__Stats__t.html#a2">reset</a>();
00194             <span class="keywordflow">if</span> (pMMFIParam) pMMFIParam-&gt;<a class="code" href="structMM__FailInsertParam.html#a1">reset</a>();
00195         };
00196 
<a name="l00197"></a><a class="code" href="classOsclMemStatsNode.html#a2">00197</a>         <a class="code" href="classOsclMemStatsNode.html#a2">~OsclMemStatsNode</a>()
00198         {
00199             <a class="code" href="group__osclmemory.html#a57">OSCL_DELETE</a>(pMMStats);
00200             <a class="code" href="group__osclmemory.html#a57">OSCL_DELETE</a>(pMMFIParam);
00201             <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;char, OsclMemBasicAllocator&gt;</a> charAlloc;
00202             charAlloc.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>(<a class="code" href="classOsclMemStatsNode.html#m2">tag</a>);
00203         }
00204 
<a name="l00205"></a><a class="code" href="classOsclMemStatsNode.html#a3">00205</a>         <span class="keywordtype">void</span> *<a class="code" href="classOsclMemStatsNode.html#a3">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> size)
00206         {
00207             <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(size);
00208             <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;OsclMemStatsNode, OsclMemBasicAllocator&gt;</a> statsNodeAlloc;
00209             <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *ptr = statsNodeAlloc.<a class="code" href="classOscl__TAlloc.html#a2">allocate</a>(1);
00210             <span class="keywordflow">return</span> ptr;
00211         };
00212 
<a name="l00213"></a><a class="code" href="classOsclMemStatsNode.html#a4">00213</a>         <span class="keywordtype">void</span> *<a class="code" href="classOsclMemStatsNode.html#a3">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> size, <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* ptr)
00214         {
00215             <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(size);
00216             <span class="keywordflow">return</span> ptr;
00217         };
00218 
00219 
<a name="l00220"></a><a class="code" href="classOsclMemStatsNode.html#a5">00220</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemStatsNode.html#a5">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
00221         {
00222             <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;OsclMemStatsNode, OsclMemBasicAllocator&gt;</a> statsNodeAlloc;
00223             statsNodeAlloc.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>((<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>*)ptr);
00224         };
00225 
00226         <span class="comment">/* won't build on ADS</span>
00227 <span class="comment">        void operator delete(void *ptr, OsclMemStatsNode* mptr) {</span>
00228 <span class="comment">            OSCL_UNUSED_ARG(ptr);</span>
00229 <span class="comment">            OSCL_UNUSED_ARG(mptr);</span>
00230 <span class="comment">        };*/</span>
00231 };
00232 
<a name="l00233"></a><a class="code" href="structMM__Stats__CB.html">00233</a> <span class="keyword">struct </span><a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a>
00234 {
<a name="l00235"></a><a class="code" href="structMM__Stats__CB.html#m0">00235</a>     <span class="keyword">const</span> <span class="keywordtype">char</span> *<a class="code" href="structMM__Stats__CB.html#m0">tag</a>;
<a name="l00236"></a><a class="code" href="structMM__Stats__CB.html#m1">00236</a>     <span class="keyword">const</span> <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a> *<a class="code" href="structMM__Stats__CB.html#m1">pStats</a>;
<a name="l00237"></a><a class="code" href="structMM__Stats__CB.html#m2">00237</a>     uint32 <a class="code" href="structMM__Stats__CB.html#m2">num_child_nodes</a>;
00238 
<a name="l00239"></a><a class="code" href="structMM__Stats__CB.html#a0">00239</a>     <a class="code" href="structMM__Stats__CB.html#a0">MM_Stats_CB</a>()
00240     {
00241         <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a>));
00242     }
00243 
<a name="l00244"></a><a class="code" href="structMM__Stats__CB.html#a1">00244</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__Stats__CB.html#a1">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> size)
00245     {
00246         <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(size);
00247         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_Stats_CB, OsclMemBasicAllocator&gt;</a> statsCBAlloc;
00248         <a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a> *ptr = statsCBAlloc.<a class="code" href="classOscl__TAlloc.html#a2">allocate</a>(1);
00249         <span class="keywordflow">return</span> ptr;
00250     };
00251 
<a name="l00252"></a><a class="code" href="structMM__Stats__CB.html#a2">00252</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__Stats__CB.html#a1">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> size, <a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a>* ptr)
00253     {
00254         <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(size);
00255         <span class="keywordflow">return</span> ptr;
00256     };
00257 
00258 
<a name="l00259"></a><a class="code" href="structMM__Stats__CB.html#a3">00259</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__Stats__CB.html#a3">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
00260     {
00261         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_Stats_CB, OsclMemBasicAllocator&gt;</a> statsCBAlloc;
00262         statsCBAlloc.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>((<a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a>*)ptr);
00263     };
00264 
00265     <span class="comment">/* won't build on ADS</span>
00266 <span class="comment">    void operator delete(void *ptr, MM_Stats_CB* mptr) {</span>
00267 <span class="comment">        OSCL_UNUSED_ARG(ptr);</span>
00268 <span class="comment">        OSCL_UNUSED_ARG(mptr);</span>
00269 <span class="comment">    };*/</span>
00270 };
00271 
<a name="l00272"></a><a class="code" href="group__osclmemory.html#a63">00272</a> <span class="preprocessor">#define MM_ALLOC_MAX_QUERY_FILENAME_LEN 128</span>
<a name="l00273"></a><a class="code" href="group__osclmemory.html#a64">00273</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_ALLOC_MAX_QUERY_TAG_LEN 64</span>
00274 <span class="preprocessor"></span>
<a name="l00275"></a><a class="code" href="structMM__AllocQueryInfo.html">00275</a> <span class="keyword">struct </span><a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>
00276 {
<a name="l00277"></a><a class="code" href="structMM__AllocQueryInfo.html#m0">00277</a>     uint32 <a class="code" href="structMM__AllocQueryInfo.html#m0">allocNum</a>;
<a name="l00278"></a><a class="code" href="structMM__AllocQueryInfo.html#m1">00278</a>     <span class="keywordtype">char</span> <a class="code" href="structMM__AllocQueryInfo.html#m1">fileName</a>[<a class="code" href="group__osclmemory.html#a63">MM_ALLOC_MAX_QUERY_FILENAME_LEN</a>];
<a name="l00279"></a><a class="code" href="structMM__AllocQueryInfo.html#m2">00279</a>     uint32 <a class="code" href="structMM__AllocQueryInfo.html#m2">lineNo</a>;
<a name="l00280"></a><a class="code" href="structMM__AllocQueryInfo.html#m3">00280</a>     uint32 <a class="code" href="structMM__AllocQueryInfo.html#m3">size</a>;
<a name="l00281"></a><a class="code" href="structMM__AllocQueryInfo.html#m4">00281</a>     <span class="keyword">const</span> <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocQueryInfo.html#m4">pMemBlock</a>;
<a name="l00282"></a><a class="code" href="structMM__AllocQueryInfo.html#m5">00282</a>     <span class="keywordtype">char</span> <a class="code" href="structMM__AllocQueryInfo.html#m5">tag</a>[<a class="code" href="group__osclmemory.html#a64">MM_ALLOC_MAX_QUERY_TAG_LEN</a>];
00283 };
00284 
00285 
<a name="l00286"></a><a class="code" href="structMM__AllocInfo.html">00286</a> <span class="keyword">struct </span><a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a>
00287 {
<a name="l00288"></a><a class="code" href="structMM__AllocInfo.html#m0">00288</a>     uint32 <a class="code" href="structMM__AllocInfo.html#m0">allocNum</a>;
<a name="l00289"></a><a class="code" href="structMM__AllocInfo.html#m1">00289</a>     <span class="keywordtype">char</span> *<a class="code" href="structMM__AllocInfo.html#m1">pFileName</a>;
<a name="l00290"></a><a class="code" href="structMM__AllocInfo.html#m2">00290</a>     uint32 <a class="code" href="structMM__AllocInfo.html#m2">lineNo</a>;
<a name="l00291"></a><a class="code" href="structMM__AllocInfo.html#m3">00291</a>     uint32 <a class="code" href="structMM__AllocInfo.html#m3">size</a>;
<a name="l00292"></a><a class="code" href="structMM__AllocInfo.html#m4">00292</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocInfo.html#m4">pMemBlock</a>;
<a name="l00293"></a><a class="code" href="structMM__AllocInfo.html#m5">00293</a>     <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *<a class="code" href="structMM__AllocInfo.html#m5">pStatsNode</a>;
<a name="l00294"></a><a class="code" href="structMM__AllocInfo.html#m6">00294</a>     <span class="keywordtype">bool</span> <a class="code" href="structMM__AllocInfo.html#m6">bSetFailure</a>;
00295 
<a name="l00296"></a><a class="code" href="structMM__AllocInfo.html#a0">00296</a>     <a class="code" href="structMM__AllocInfo.html#a0">MM_AllocInfo</a>()
00297     {
00298         <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a>));
00299     }
00300 
<a name="l00301"></a><a class="code" href="structMM__AllocInfo.html#a1">00301</a>     <a class="code" href="structMM__AllocInfo.html#a1">~MM_AllocInfo</a>()
00302     {
00303         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;char, OsclMemBasicAllocator&gt;</a> charAlloc;
00304         charAlloc.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>(<a class="code" href="structMM__AllocInfo.html#m1">pFileName</a>);
00305     }
00306 
00307 
<a name="l00308"></a><a class="code" href="structMM__AllocInfo.html#a2">00308</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocInfo.html#a2">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> <a class="code" href="structMM__AllocInfo.html#m3">size</a>)
00309     {
00310         <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(<a class="code" href="structMM__AllocInfo.html#m3">size</a>);
00311         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_AllocInfo, OsclMemBasicAllocator&gt;</a> allocInfoAlloc;
00312         <a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a> *ptr = allocInfoAlloc.<a class="code" href="classOscl__TAlloc.html#a2">allocate</a>(1);
00313         <span class="keywordflow">return</span> ptr;
00314     };
00315 
<a name="l00316"></a><a class="code" href="structMM__AllocInfo.html#a3">00316</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocInfo.html#a2">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> <a class="code" href="structMM__AllocInfo.html#m3">size</a>, <a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a>* ptr)
00317     {
00318         <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(<a class="code" href="structMM__AllocInfo.html#m3">size</a>);
00319         <span class="keywordflow">return</span> ptr;
00320     };
00321 
00322 
<a name="l00323"></a><a class="code" href="structMM__AllocInfo.html#a4">00323</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__AllocInfo.html#a4">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
00324     {
00325         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_AllocInfo, OsclMemBasicAllocator&gt;</a> allocInfoAlloc;
00326         allocInfoAlloc.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>((<a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a>*)ptr);
00327     };
00328 
00329     <span class="comment">/* won't build on ADS</span>
00330 <span class="comment">    void operator delete(void *ptr, MM_AllocInfo* mptr) {</span>
00331 <span class="comment">        OSCL_UNUSED_ARG(ptr);</span>
00332 <span class="comment">        OSCL_UNUSED_ARG(mptr);</span>
00333 <span class="comment">    };*/</span>
00334 };
00335 
00336 
<a name="l00337"></a><a class="code" href="structMM__AllocNode.html">00337</a> <span class="keyword">struct </span><a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>
00338 {
<a name="l00339"></a><a class="code" href="structMM__AllocNode.html#m0">00339</a>     <a class="code" href="structMM__AllocInfo.html">MM_AllocInfo</a> *<a class="code" href="structMM__AllocNode.html#m0">pAllocInfo</a>;
00340 
<a name="l00341"></a><a class="code" href="structMM__AllocNode.html#m1">00341</a>     <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a> *<a class="code" href="structMM__AllocNode.html#m1">pPrev</a>;
<a name="l00342"></a><a class="code" href="structMM__AllocNode.html#m2">00342</a>     <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a> *<a class="code" href="structMM__AllocNode.html#m2">pNext</a>;
<a name="l00343"></a><a class="code" href="structMM__AllocNode.html#a0">00343</a>     <a class="code" href="structMM__AllocNode.html#a0">MM_AllocNode</a>()
00344     {
00345         <a class="code" href="group__osclmemory.html#a14">oscl_memset</a>(<span class="keyword">this</span>, 0, <span class="keyword">sizeof</span>(<a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>));
00346     }
00347 
<a name="l00348"></a><a class="code" href="structMM__AllocNode.html#a1">00348</a>     <a class="code" href="structMM__AllocNode.html#a1">~MM_AllocNode</a>()
00349     {
00350         <a class="code" href="group__osclmemory.html#a57">OSCL_DELETE</a>(pAllocInfo);
00351     }
00352 
<a name="l00353"></a><a class="code" href="structMM__AllocNode.html#a2">00353</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocNode.html#a2">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> size)
00354     {
00355         <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(size);
00356         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_AllocNode, OsclMemBasicAllocator&gt;</a> allocNodeAlloc;
00357         <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a> *ptr = allocNodeAlloc.<a class="code" href="classOscl__TAlloc.html#a2">allocate</a>(1);
00358         <span class="keywordflow">return</span> ptr;
00359     };
00360 
<a name="l00361"></a><a class="code" href="structMM__AllocNode.html#a3">00361</a>     <span class="keywordtype">void</span> *<a class="code" href="structMM__AllocNode.html#a2">operator new</a>(<a class="code" href="osclconfig__ansi__memory_8h.html#a1">oscl_memsize_t</a> size, <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>* ptr)
00362     {
00363         <a class="code" href="group__osclbase.html#a89">OSCL_UNUSED_ARG</a>(size);
00364         <span class="keywordflow">return</span> ptr;
00365     };
00366 
00367 
<a name="l00368"></a><a class="code" href="structMM__AllocNode.html#a4">00368</a>     <span class="keywordtype">void</span> <a class="code" href="structMM__AllocNode.html#a4">operator delete</a>(<span class="keywordtype">void</span> *ptr) <span class="keywordflow">throw</span>()
00369     {
00370         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_AllocNode, OsclMemBasicAllocator&gt;</a> allocNodeAlloc;
00371         allocNodeAlloc.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>((<a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>*)ptr);
00372     };
00373 
00374     <span class="comment">/* won't build on ADS</span>
00375 <span class="comment">    void operator delete(void *ptr, MM_AllocNode* mptr) {</span>
00376 <span class="comment">        OSCL_UNUSED_ARG(ptr);</span>
00377 <span class="comment">        OSCL_UNUSED_ARG(mptr);</span>
00378 <span class="comment">    };*/</span>
00379 };
00380 
00381 
00382 <span class="comment">/* Define internal auto ptr classes that don't go through mem mgmt */</span>
<a name="l00383"></a><a class="code" href="group__osclmemory.html#a0">00383</a> <span class="keyword">typedef</span> <a class="code" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr&lt;char, Oscl_TAlloc&lt;char, OsclMemBasicAllocator&gt;</a> &gt; <a class="code" href="classOSCLMemAutoPtr.html">MMAuditCharAutoPtr</a>;
<a name="l00384"></a><a class="code" href="group__osclmemory.html#a1">00384</a> <span class="keyword">typedef</span> <a class="code" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr&lt;uint8, Oscl_TAlloc&lt;uint8, _OsclBasicAllocator&gt;</a> &gt; <a class="code" href="classOSCLMemAutoPtr.html">MMAuditUint8AutoPtr</a>;
<a name="l00385"></a><a class="code" href="group__osclmemory.html#a2">00385</a> <span class="keyword">typedef</span> <a class="code" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr&lt;MM_AllocNode, Oscl_TAlloc&lt;MM_AllocNode, OsclMemBasicAllocator&gt;</a> &gt; <a class="code" href="classOSCLMemAutoPtr.html">MM_AllocNodeAutoPtr</a>;
00386 
<a name="l00387"></a><a class="code" href="group__osclmemory.html#a3">00387</a> <span class="keyword">typedef</span> <a class="code" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr&lt;OsclMemStatsNode, Oscl_TAlloc&lt;OsclMemStatsNode, OsclMemBasicAllocator&gt;</a> &gt; <a class="code" href="classOSCLMemAutoPtr.html">MM_StatsNodeTagTreeType</a>;
<a name="l00388"></a><a class="code" href="group__osclmemory.html#a4">00388</a> <span class="keyword">typedef</span> <a class="code" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr&lt;OsclMemStatsNode, Oscl_TAlloc&lt;OsclMemStatsNode, OsclMemBasicAllocator&gt;</a> &gt; <a class="code" href="classOSCLMemAutoPtr.html">OsclMemStatsNodeAutoPtr</a>;
<a name="l00389"></a><a class="code" href="group__osclmemory.html#a5">00389</a> <span class="keyword">typedef</span> <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;MM_StatsNodeTagTreeType, OsclMemBasicAllocator&gt;</a> <a class="code" href="classOscl__TAlloc.html">TagTree_Allocator</a>;
<a name="l00390"></a><a class="code" href="group__osclmemory.html#a6">00390</a> <span class="keyword">typedef</span> <a class="code" href="classOscl__TagTree.html">Oscl_TagTree&lt;MM_StatsNodeTagTreeType, TagTree_Allocator&gt;</a> <a class="code" href="classOscl__TagTree.html">OsclTagTreeType</a>;
00391 
00392 
<a name="l00393"></a><a class="code" href="group__osclmemory.html#a65">00393</a> <span class="preprocessor">#define MM_AUDIT_VALIDATE_BLOCK 1</span>
<a name="l00394"></a><a class="code" href="group__osclmemory.html#a66">00394</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_PREFILL_FLAG 0x1</span>
<a name="l00395"></a><a class="code" href="group__osclmemory.html#a67">00395</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_POSTFILL_FLAG 0x2</span>
<a name="l00396"></a><a class="code" href="group__osclmemory.html#a68">00396</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_VALIDATE_ALL_HEAP_FLAG 0x4</span>
<a name="l00397"></a><a class="code" href="group__osclmemory.html#a69">00397</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_VALIDATE_ON_FREE_FLAG 0x8</span>
<a name="l00398"></a><a class="code" href="group__osclmemory.html#a70">00398</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_ALLOC_NODE_ENABLE_FLAG 0x10</span>
<a name="l00399"></a><a class="code" href="group__osclmemory.html#a71">00399</a> <span class="preprocessor"></span><span class="preprocessor">#define MM_AUDIT_SUPPRESS_FILENAME_FLAG 0x20</span>
00400 <span class="preprocessor"></span>
00401 <span class="preprocessor">#if(PVMEM_INST_LEVEL&gt;0)</span>
00402 <span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_MM_AUDIT_MODE (MM_AUDIT_PREFILL_FLAG | \</span>
00403 <span class="preprocessor">                               MM_AUDIT_POSTFILL_FLAG | \</span>
00404 <span class="preprocessor">                               MM_AUDIT_VALIDATE_ON_FREE_FLAG | \</span>
00405 <span class="preprocessor">                               MM_AUDIT_ALLOC_NODE_ENABLE_FLAG )</span>
00406 <span class="preprocessor"></span>
00407 
00408 
00409 <span class="preprocessor">#else</span>
<a name="l00410"></a><a class="code" href="group__osclmemory.html#a72">00410</a> <span class="preprocessor"></span><span class="preprocessor">#define DEFAULT_MM_AUDIT_MODE 0</span>
00411 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00412 <span class="preprocessor"></span>
00413 
<a name="l00414"></a><a class="code" href="structMM__AuditOverheadStats.html">00414</a> <span class="keyword">struct </span><a class="code" href="structMM__AuditOverheadStats.html">MM_AuditOverheadStats</a>
00415 {
<a name="l00416"></a><a class="code" href="structMM__AuditOverheadStats.html#m0">00416</a>     uint32 <a class="code" href="structMM__AuditOverheadStats.html#m0">per_allocation_overhead</a>;
<a name="l00417"></a><a class="code" href="structMM__AuditOverheadStats.html#m1">00417</a>     uint32 <a class="code" href="structMM__AuditOverheadStats.html#m1">stats_overhead</a>;
00418 };
00419 
00420 <span class="preprocessor">#if OSCL_BYPASS_MEMMGT</span>
00421 <span class="preprocessor"></span><span class="comment">//an empty class for compilation only</span>
00422 <span class="keyword">class </span><a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a>
00423 {
00424     <span class="keyword">public</span>:
00425 };
00426 <span class="preprocessor">#else</span>
<a name="l00427"></a><a class="code" href="classMM__Audit__Imp.html">00427</a> <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a>
00428 {
00429     <span class="keyword">public</span>:
00430 
00434         <a class="code" href="classMM__Audit__Imp.html#a0">MM_Audit_Imp</a>();
00435 
00439         <a class="code" href="classMM__Audit__Imp.html#a1">~MM_Audit_Imp</a>();
00440 
00447         OSCL_IMPORT_REF <span class="keywordtype">void</span> *<a class="code" href="classMM__Audit__Imp.html#a2">MM_allocate</a>(<span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>*  statsNode,
00448                                           uint32 sizeIn,
00449                                           <span class="keyword">const</span> <span class="keywordtype">char</span> *pFileName,
00450                                           uint32 lineNumber,
00451                                           <span class="keywordtype">bool</span> allocNodeTracking = <span class="keyword">false</span>);
00452 
00456         OSCL_IMPORT_REF <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a3">MM_deallocate</a>(<span class="keywordtype">void</span> *pMemBlockIn);
00457 
00462         OSCL_IMPORT_REF <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a> * <a class="code" href="classMM__Audit__Imp.html#a4">MM_GetStats</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span>  tagIn);
00463 
00468         OSCL_IMPORT_REF uint32 <a class="code" href="classMM__Audit__Imp.html#a5">MM_GetStatsInDepth</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn, <a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a> *array_ptr, uint32 max_nodes);
00469 
00475         OSCL_IMPORT_REF uint32 <a class="code" href="classMM__Audit__Imp.html#a6">MM_GetTreeNodes</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn);
00476 
<a name="l00482"></a><a class="code" href="classMM__Audit__Imp.html#a7">00482</a>         OSCL_IMPORT_REF <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a7">MM_AddTag</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
00483         {
00484             <span class="keywordflow">return</span> (<a class="code" href="classMM__Audit__Imp.html#a8">MM_GetTagNode</a>(tagIn) != <a class="code" href="group__osclbase.html#a81">NULL</a>);
00485         };
00486 
00493         OSCL_IMPORT_REF <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* <a class="code" href="classMM__Audit__Imp.html#a8">MM_GetTagNode</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
00494 
00495 
00502         OSCL_IMPORT_REF <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* <a class="code" href="classMM__Audit__Imp.html#a9">MM_GetExistingTag</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
00503 
00504 
<a name="l00505"></a><a class="code" href="classMM__Audit__Imp.html#a10">00505</a>         OSCL_IMPORT_REF <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* <a class="code" href="classMM__Audit__Imp.html#a10">MM_GetRootNode</a>()
00506         {
00507             <span class="keywordflow">return</span> mpStatsNode;
00508         };
00509 
00514         OSCL_IMPORT_REF <a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* <a class="code" href="classMM__Audit__Imp.html#a11">MM_CreateAllocNodeInfo</a>(uint32 max_array_size);
00515         OSCL_IMPORT_REF <span class="keywordtype">void</span> <a class="code" href="classMM__Audit__Imp.html#a12">MM_ReleaseAllocNodeInfo</a>(<a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* info);
00516 
00526         OSCL_IMPORT_REF uint32 <a class="code" href="classMM__Audit__Imp.html#a13">MM_GetAllocNodeInfo</a>(<a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* output_array,
00527                 uint32 max_array_size, uint32 offset);
00528 
00534         OSCL_IMPORT_REF <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a14">MM_Validate</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *ptrIn);
00535 
<a name="l00540"></a><a class="code" href="classMM__Audit__Imp.html#a15">00540</a>         uint32 <a class="code" href="classMM__Audit__Imp.html#a15">MM_GetAllocNo</a>(<span class="keywordtype">void</span>)
00541         {
00542             <span class="keywordflow">return</span> mnAllocNum;
00543         }
00544 
<a name="l00549"></a><a class="code" href="classMM__Audit__Imp.html#a16">00549</a>         <span class="keywordtype">void</span> <a class="code" href="classMM__Audit__Imp.html#a16">MM_GetOverheadStats</a>(<a class="code" href="structMM__AuditOverheadStats.html">MM_AuditOverheadStats</a>&amp; stats)
00550         {
00551             stats.<a class="code" href="structMM__AuditOverheadStats.html#m0">per_allocation_overhead</a> = mm_audit_per_block_overhead;
00552             stats.<a class="code" href="structMM__AuditOverheadStats.html#m1">stats_overhead</a> = mm_audit_stats_overhead;
00553         }
00554 
<a name="l00559"></a><a class="code" href="classMM__Audit__Imp.html#a17">00559</a>         uint32 <a class="code" href="classMM__Audit__Imp.html#a17">MM_GetNumAllocNodes</a>()
00560         {
00561             <span class="keywordflow">return</span> mNumAllocNodes;
00562         };
00563 
<a name="l00567"></a><a class="code" href="classMM__Audit__Imp.html#a18">00567</a>         uint32 <a class="code" href="classMM__Audit__Imp.html#a18">MM_GetMode</a>(<span class="keywordtype">void</span>)
00568         {
00569             <span class="keywordflow">return</span> mode;
00570         }
00571 
<a name="l00576"></a><a class="code" href="classMM__Audit__Imp.html#a19">00576</a>         uint8 <a class="code" href="classMM__Audit__Imp.html#a19">MM_GetPrefillPattern</a>(<span class="keywordtype">void</span>)
00577         {
00578             <span class="keywordflow">return</span> prefill_pattern;
00579         }
00580 
<a name="l00585"></a><a class="code" href="classMM__Audit__Imp.html#a20">00585</a>         uint32 <a class="code" href="classMM__Audit__Imp.html#a20">MM_GetPostfillPattern</a>(<span class="keywordtype">void</span>)
00586         {
00587             <span class="keywordflow">return</span> postfill_pattern;
00588         }
00589 
00593         OSCL_IMPORT_REF <span class="keywordtype">void</span> <a class="code" href="classMM__Audit__Imp.html#a21">MM_SetMode</a>(uint32 inMode);
00594 
00598         OSCL_IMPORT_REF <span class="keywordtype">void</span> <a class="code" href="classMM__Audit__Imp.html#a22">MM_SetPrefillPattern</a>(uint8 pattern);
00599 
00603         OSCL_IMPORT_REF <span class="keywordtype">void</span> <a class="code" href="classMM__Audit__Imp.html#a23">MM_SetPostfillPattern</a>(uint8 pattern);
00604 
00609         OSCL_IMPORT_REF <span class="keywordtype">void</span> <a class="code" href="classMM__Audit__Imp.html#a24">MM_SetTagLevel</a>(uint32 level);
00610 
00617         OSCL_IMPORT_REF <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a25">MM_SetFailurePoint</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn, uint32 alloc_number);
00618 
00623         OSCL_IMPORT_REF <span class="keywordtype">void</span> <a class="code" href="classMM__Audit__Imp.html#a26">MM_UnsetFailurePoint</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
00624 
00625 
00626         <span class="comment">/*</span>
00627 <span class="comment">        * The following are private member functions</span>
00628 <span class="comment">        */</span>
00629 
00630 
00634         <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>* <a class="code" href="classMM__Audit__Imp.html#a27">addAllocNode</a>(<span class="keywordtype">void</span> *pMem, uint32 sizeIn, <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* pStatsNode, <span class="keyword">const</span> <span class="keywordtype">char</span> *pFileName, uint32 lineNumber);
00638         <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* <a class="code" href="classMM__Audit__Imp.html#a28">removeAllocNode</a>(<span class="keywordtype">void</span> *pMemBlockIn, uint32&amp; size);
00639         <span class="keywordtype">void</span> <a class="code" href="classMM__Audit__Imp.html#a29">removeALLAllocNodes</a>();
00640 
00644         <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* <a class="code" href="classMM__Audit__Imp.html#a30">createStatsNode</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn);
00648         <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a31">updateStatsNode</a>(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *pCurrStatsNode,
00649                              <span class="keyword">const</span> <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>&amp; pDelta, <span class="keywordtype">bool</span> bAdd);
00653         <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a32">updateStatsNodeInFailure</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
00654         <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a32">updateStatsNodeInFailure</a>(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> * pStatsNode);
00658         <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a34">pruneSubtree</a>(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *pNode);
00659         <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a34">pruneSubtree</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
00660 
00661         <span class="keywordtype">void</span> <a class="code" href="classMM__Audit__Imp.html#a36">retrieveParentTag</a>(<span class="keywordtype">char</span> *tag);
00665         int32 <a class="code" href="classMM__Audit__Imp.html#a37">retrieveParentTagLength</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *tag, int32 bound);
00669         <span class="keywordtype">void</span> <a class="code" href="classMM__Audit__Imp.html#a38">makeValidTag</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn, MMAuditCharAutoPtr&amp; autoptr);
00673         uint32 <a class="code" href="classMM__Audit__Imp.html#a39">getTagActualSize</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
00680         <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a40">isSetFailure</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn);
00681 
00682         <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a40">isSetFailure</a>(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> * statsNode);
00686         <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#d0">validate</a>(<span class="keywordtype">void</span> *ptrIn);
00687 
00691         <span class="keyword">static</span> <a class="code" href="classOsclMemAudit.html">OsclMemAudit</a>* <a class="code" href="classMM__Audit__Imp.html#d1">getAuditRoot</a>(<span class="keywordtype">void</span> *ptrIn);
00692 
00696         <span class="keyword">static</span> uint32 <a class="code" href="classMM__Audit__Imp.html#d2">getSize</a>(<span class="keywordtype">void</span> *ptrIn);
00697 
00701         <span class="keywordtype">bool</span> <a class="code" href="classMM__Audit__Imp.html#a42">validate_all_heap</a>();
00702 
00703     <span class="keyword">private</span>:
00704 
00705         <span class="keywordtype">void</span> populateChildren(<span class="keyword">const</span> <span class="keywordtype">char</span> *tagIn,
00706                               <a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a> *array_ptr,
00707                               uint32 &amp;curr_array_index,
00708                               uint32 max_nodes);
00709 
00710         <span class="comment">/*</span>
00711 <span class="comment">        * The following are private data members</span>
00712 <span class="comment">        */</span>
00713 
00718         <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a> *mpAllocNode, *mpCurrAllocNode;
00719 
00724         uint32 mNumAllocNodes;
00725 
00729         <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *mpStatsNode;
00734         OsclTagTreeType          mTagTree;
00738         uint32 mnAllocNum;
00739         uint32 mnMaxTagLevel;
00740         uint32 mode;
00741 
00742         uint32 mm_audit_per_block_overhead;
00743         uint32 mm_audit_stats_overhead;
00744 
00745         uint8 prefill_pattern;
00746         uint8 postfill_pattern;
00747 
00748 };
00749 <span class="preprocessor">#endif</span>
00750 <span class="preprocessor"></span>
00751 <span class="preprocessor">#if OSCL_BYPASS_MEMMGT</span>
00752 <span class="preprocessor"></span><span class="comment">//an empty class for compilation only.</span>
00753 <span class="keyword">class </span><a class="code" href="classOsclMemAudit.html">OsclMemAudit</a>
00754 {
00755     <span class="keyword">public</span>:
00756 };
00757 <span class="preprocessor">#else</span>
<a name="l00758"></a><a class="code" href="classOsclMemAudit.html">00758</a> <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classOsclMemAudit.html">OsclMemAudit</a>
00759 {
00760     <span class="keyword">public</span>:
<a name="l00764"></a><a class="code" href="classOsclMemAudit.html#a0">00764</a>         <a class="code" href="classOsclMemAudit.html#a0">OsclMemAudit</a>()
00765         {
00766             <span class="keywordtype">void</span> * p = <a class="code" href="group__osclmemory.html#a7">_oscl_malloc</a>(<span class="keyword">sizeof</span>(<a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a>));
00767             <a class="code" href="classOsclError.html#d8">OsclError::LeaveIfNull</a>(p);
00768 
00769             <span class="comment">// this will invoke system placement new operator</span>
00770             _pMM_Audit_Imp = <a class="code" href="group__osclmemory.html#a53">OSCL_PLACEMENT_NEW</a>(p, <a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a>());
00771             iLock = &amp;iSingletonLock;
00772             iRefCount = 1;
00773         };
00774 
<a name="l00778"></a><a class="code" href="classOsclMemAudit.html#a1">00778</a>         <a class="code" href="classOsclMemAudit.html#a1">~OsclMemAudit</a>()
00779         {
00780             _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a1">~MM_Audit_Imp</a>();
00781             <a class="code" href="group__osclmemory.html#a10">_oscl_free</a>((<span class="keywordtype">void</span> *) _pMM_Audit_Imp);
00782         };
00783 
<a name="l00790"></a><a class="code" href="classOsclMemAudit.html#a2">00790</a>         <span class="keywordtype">void</span> *<a class="code" href="classOsclMemAudit.html#a2">MM_allocate</a>(<span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>*  statsNode,
00791                           uint32 sizeIn,
00792                           <span class="keyword">const</span> <span class="keywordtype">char</span> *pFileName,
00793                           uint32 lineNumber,
00794                           <span class="keywordtype">bool</span> allocNodeTracking = <span class="keyword">false</span>)
00795         {
00796             <span class="comment">// make sure lock is acquired and freed up upon return</span>
00797             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
00798 
00799             <span class="keywordtype">void</span>* result = _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a2">MM_allocate</a>(statsNode, sizeIn, pFileName, lineNumber, allocNodeTracking);
00800 
00801             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
00802             <span class="keywordflow">return</span> result;
00803         };
00804 
<a name="l00808"></a><a class="code" href="classOsclMemAudit.html#a3">00808</a>         <span class="keywordtype">bool</span> <a class="code" href="classOsclMemAudit.html#a3">MM_deallocate</a>(<span class="keywordtype">void</span> *pMemBlockIn)
00809         {
00810             <span class="comment">// make sure lock is acquired and freed up upon return</span>
00811             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
00812 
00813             <span class="keywordtype">bool</span> result = _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a3">MM_deallocate</a>(pMemBlockIn);
00814 
00815             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
00816             <span class="keywordflow">return</span> result;
00817         };
00818 
<a name="l00823"></a><a class="code" href="classOsclMemAudit.html#a4">00823</a>         <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a> * <a class="code" href="classOsclMemAudit.html#a4">MM_GetStats</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span>  tagIn)
00824         {
00825             <span class="comment">// make sure lock is acquired and freed up upon return</span>
00826             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
00827 
00828             <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>* result = (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a4">MM_GetStats</a>(tagIn));
00829 
00830             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
00831             <span class="keywordflow">return</span> result;
00832         };
00833 
<a name="l00838"></a><a class="code" href="classOsclMemAudit.html#a5">00838</a>         uint32 <a class="code" href="classOsclMemAudit.html#a5">MM_GetStatsInDepth</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn, <a class="code" href="structMM__Stats__CB.html">MM_Stats_CB</a> *array_ptr, uint32 max_nodes)
00839         {
00840             <span class="comment">// make sure lock is acquired and freed up upon return</span>
00841             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
00842 
00843             uint32 result = (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a5">MM_GetStatsInDepth</a>(tagIn, array_ptr, max_nodes));
00844 
00845             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
00846             <span class="keywordflow">return</span> result;
00847         };
00848 
<a name="l00854"></a><a class="code" href="classOsclMemAudit.html#a6">00854</a>         uint32 <a class="code" href="classOsclMemAudit.html#a6">MM_GetTreeNodes</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn)
00855         {
00856             <span class="comment">// make sure lock is acquired and freed up upon return</span>
00857             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
00858 
00859             uint32 result = (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a6">MM_GetTreeNodes</a>(tagIn));
00860 
00861             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
00862             <span class="keywordflow">return</span> result;
00863         };
00864 
<a name="l00870"></a><a class="code" href="classOsclMemAudit.html#a7">00870</a>         <span class="keywordtype">bool</span> <a class="code" href="classOsclMemAudit.html#a7">MM_AddTag</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
00871         {
00872             <span class="keywordflow">return</span> (<a class="code" href="classOsclMemAudit.html#a8">MM_GetTagNode</a>(tagIn) != <a class="code" href="group__osclbase.html#a81">NULL</a>);
00873         };
00874 
<a name="l00881"></a><a class="code" href="classOsclMemAudit.html#a8">00881</a>         <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* <a class="code" href="classOsclMemAudit.html#a8">MM_GetTagNode</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
00882         {
00883             <span class="comment">// make sure lock is acquired and freed up upon return</span>
00884             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
00885 
00886             <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* result = (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a8">MM_GetTagNode</a>(tagIn));
00887 
00888             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
00889             <span class="keywordflow">return</span> result;
00890         };
00891 
00892 
<a name="l00899"></a><a class="code" href="classOsclMemAudit.html#a9">00899</a>         <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* <a class="code" href="classOsclMemAudit.html#a9">MM_GetExistingTag</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
00900         {
00901             <span class="comment">// make sure lock is acquired and freed up upon return</span>
00902             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
00903 
00904             <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* result = (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a9">MM_GetExistingTag</a>(tagIn));
00905 
00906             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
00907             <span class="keywordflow">return</span> result;
00908         };
00909 
00910 
<a name="l00911"></a><a class="code" href="classOsclMemAudit.html#a10">00911</a>         <span class="keyword">const</span> <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* <a class="code" href="classOsclMemAudit.html#a10">MM_GetRootNode</a>()
00912         {
00913             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a10">MM_GetRootNode</a>());
00914         };
00915 
<a name="l00925"></a><a class="code" href="classOsclMemAudit.html#a11">00925</a>         uint32 <a class="code" href="classOsclMemAudit.html#a11">MM_GetAllocNodeInfo</a>(<a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* output_array,
00926                                    uint32 max_array_size, uint32 offset)
00927         {
00928             <span class="comment">// make sure lock is acquired and freed up upon return</span>
00929             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
00930 
00931             uint32 result = (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a13">MM_GetAllocNodeInfo</a>(output_array, max_array_size, offset));
00932 
00933             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
00934             <span class="keywordflow">return</span> result;
00935         };
00936 
<a name="l00937"></a><a class="code" href="classOsclMemAudit.html#a12">00937</a>         <a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* <a class="code" href="classOsclMemAudit.html#a12">MM_CreateAllocNodeInfo</a>(uint32 max_array_size)
00938         {
00939             <span class="keywordflow">return</span> _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a11">MM_CreateAllocNodeInfo</a>(max_array_size);
00940         }
<a name="l00941"></a><a class="code" href="classOsclMemAudit.html#a13">00941</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemAudit.html#a13">MM_ReleaseAllocNodeInfo</a>(<a class="code" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a>* info)
00942         {
00943             _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a12">MM_ReleaseAllocNodeInfo</a>(info);
00944         }
00945 
<a name="l00951"></a><a class="code" href="classOsclMemAudit.html#a14">00951</a>         <span class="keywordtype">bool</span> <a class="code" href="classOsclMemAudit.html#a14">MM_Validate</a>(<span class="keyword">const</span> <span class="keywordtype">void</span> *ptrIn)
00952         {
00953             <span class="comment">// make sure lock is acquired and freed up upon return</span>
00954             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
00955 
00956             <span class="keywordtype">bool</span> result = (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a14">MM_Validate</a>(ptrIn));
00957 
00958             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
00959             <span class="keywordflow">return</span> result;
00960         };
00961 
<a name="l00966"></a><a class="code" href="classOsclMemAudit.html#a15">00966</a>         uint32 <a class="code" href="classOsclMemAudit.html#a15">MM_GetAllocNo</a>(<span class="keywordtype">void</span>)
00967         {
00968             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a15">MM_GetAllocNo</a>());
00969         };
00970 
<a name="l00975"></a><a class="code" href="classOsclMemAudit.html#a16">00975</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemAudit.html#a16">MM_GetOverheadStats</a>(<a class="code" href="structMM__AuditOverheadStats.html">MM_AuditOverheadStats</a>&amp; stats)
00976         {
00977             _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a16">MM_GetOverheadStats</a>(stats);
00978         };
00979 
<a name="l00984"></a><a class="code" href="classOsclMemAudit.html#a17">00984</a>         uint32 <a class="code" href="classOsclMemAudit.html#a17">MM_GetNumAllocNodes</a>()
00985         {
00986             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a17">MM_GetNumAllocNodes</a>());
00987         };
00988 
<a name="l00992"></a><a class="code" href="classOsclMemAudit.html#a18">00992</a>         uint32 <a class="code" href="classOsclMemAudit.html#a18">MM_GetMode</a>(<span class="keywordtype">void</span>)
00993         {
00994             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a18">MM_GetMode</a>());
00995         };
00996 
<a name="l01001"></a><a class="code" href="classOsclMemAudit.html#a19">01001</a>         uint8 <a class="code" href="classOsclMemAudit.html#a19">MM_GetPrefillPattern</a>(<span class="keywordtype">void</span>)
01002         {
01003             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a19">MM_GetPrefillPattern</a>());
01004         };
01005 
<a name="l01010"></a><a class="code" href="classOsclMemAudit.html#a20">01010</a>         uint32 <a class="code" href="classOsclMemAudit.html#a20">MM_GetPostfillPattern</a>(<span class="keywordtype">void</span>)
01011         {
01012             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a20">MM_GetPostfillPattern</a>());
01013         };
01014 
<a name="l01018"></a><a class="code" href="classOsclMemAudit.html#a21">01018</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemAudit.html#a21">MM_SetMode</a>(uint32 inMode)
01019         {
01020             <span class="comment">// make sure lock is acquired and freed up upon return</span>
01021             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
01022 
01023             _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a21">MM_SetMode</a>(inMode);
01024 
01025             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
01026         };
01027 
<a name="l01031"></a><a class="code" href="classOsclMemAudit.html#a22">01031</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemAudit.html#a22">MM_SetPrefillPattern</a>(uint8 pattern)
01032         {
01033             <span class="comment">// make sure lock is acquired and freed up upon return</span>
01034             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
01035 
01036             _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a22">MM_SetPrefillPattern</a>(pattern);
01037 
01038             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
01039         };
01040 
<a name="l01044"></a><a class="code" href="classOsclMemAudit.html#a23">01044</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemAudit.html#a23">MM_SetPostfillPattern</a>(uint8 pattern)
01045         {
01046             <span class="comment">// make sure lock is acquired and freed up upon return</span>
01047             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
01048 
01049             _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a23">MM_SetPostfillPattern</a>(pattern);
01050 
01051             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
01052         };
01053 
<a name="l01058"></a><a class="code" href="classOsclMemAudit.html#a24">01058</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemAudit.html#a24">MM_SetTagLevel</a>(uint32 level)
01059         {
01060             <span class="comment">// make sure lock is acquired and freed up upon return</span>
01061             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
01062 
01063             _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a24">MM_SetTagLevel</a>(level);
01064 
01065             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
01066         };
01067 
<a name="l01074"></a><a class="code" href="classOsclMemAudit.html#a25">01074</a>         <span class="keywordtype">bool</span> <a class="code" href="classOsclMemAudit.html#a25">MM_SetFailurePoint</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn, uint32 alloc_number)
01075         {
01076             <span class="comment">// make sure lock is acquired and freed up upon return</span>
01077             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
01078 
01079             <span class="keywordtype">bool</span> result = (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a25">MM_SetFailurePoint</a>(tagIn, alloc_number));
01080 
01081             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
01082             <span class="keywordflow">return</span> result;
01083         };
01084 
01085 
<a name="l01090"></a><a class="code" href="classOsclMemAudit.html#a26">01090</a>         <span class="keywordtype">void</span> <a class="code" href="classOsclMemAudit.html#a26">MM_UnsetFailurePoint</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
01091         {
01092             <span class="comment">// make sure lock is acquired and freed up upon return</span>
01093             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
01094 
01095             _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a26">MM_UnsetFailurePoint</a>(tagIn);
01096 
01097             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
01098         };
01099 
<a name="l01100"></a><a class="code" href="classOsclMemAudit.html#a27">01100</a>         int32 <a class="code" href="classOsclMemAudit.html#a27">MM_GetRefCount</a>()
01101         {
01102             int32 count;
01103             iLock-&gt;<a class="code" href="classOsclLockBase.html#a0">Lock</a>();
01104             count = iRefCount;
01105             iLock-&gt;<a class="code" href="classOsclLockBase.html#a1">Unlock</a>();
01106             <span class="keywordflow">return</span> count;
01107         }
01108 
<a name="l01114"></a><a class="code" href="classOsclMemAudit.html#a28">01114</a>         <a class="code" href="classOsclLockBase.html">OsclLockBase</a>* <a class="code" href="classOsclMemAudit.html#a28">GetLock</a>()
01115         {
01116             <span class="keywordflow">return</span> iLock;
01117         };
01118 
01119         <span class="comment">/*</span>
01120 <span class="comment">        * The following are private member functions</span>
01121 <span class="comment">        */</span>
01122 
01123     <span class="keyword">private</span>:
01127         <a class="code" href="structMM__AllocNode.html">MM_AllocNode</a>* addAllocNode(<span class="keywordtype">void</span> *pMem, uint32 sizeIn, <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* pStatsNode,
01128                                    <span class="keyword">const</span> <span class="keywordtype">char</span> *pFileName, uint32 lineNumber)
01129         {
01130             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a27">addAllocNode</a>(pMem, sizeIn, pStatsNode, pFileName, lineNumber));
01131         }
01132 
01136         <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* removeAllocNode(<span class="keywordtype">void</span> *pMemBlockIn, uint32&amp; size)
01137         {
01138             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a28">removeAllocNode</a>(pMemBlockIn, size));
01139         }
01140 
01141         <span class="keywordtype">void</span> removeALLAllocNodes()
01142         {
01143             _pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a29">removeALLAllocNodes</a>();
01144         }
01145 
01149         <a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>* createStatsNode(<span class="keyword">const</span> <span class="keywordtype">char</span> *  tagIn)
01150         {
01151             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a30">createStatsNode</a>(tagIn));
01152         }
01153 
01157         <span class="keywordtype">bool</span> updateStatsNode(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *pCurrStatsNode,
01158                              <span class="keyword">const</span> <a class="code" href="structMM__Stats__t.html">MM_Stats_t</a>&amp; pDelta, <span class="keywordtype">bool</span> bAdd)
01159         {
01160             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a31">updateStatsNode</a>(pCurrStatsNode, pDelta, bAdd));
01161         }
01162 
01166         <span class="keywordtype">bool</span> updateStatsNodeInFailure(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
01167         {
01168             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a32">updateStatsNodeInFailure</a>(tagIn));
01169         }
01170 
01171         <span class="keywordtype">bool</span> updateStatsNodeInFailure(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> * pStatsNode)
01172         {
01173             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a32">updateStatsNodeInFailure</a>(pStatsNode));
01174         }
01175 
01179         <span class="keywordtype">bool</span> pruneSubtree(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> *pNode)
01180         {
01181             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a34">pruneSubtree</a>(pNode));
01182         }
01183 
01184         <span class="keywordtype">bool</span> pruneSubtree(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
01185         {
01186             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a34">pruneSubtree</a>(tagIn));
01187         }
01188 
01189         <span class="keywordtype">void</span> retrieveParentTag(<span class="keywordtype">char</span> *tag)
01190         {
01191             (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a36">retrieveParentTag</a>(tag));
01192         }
01193 
01197         int32 retrieveParentTagLength(<span class="keyword">const</span> <span class="keywordtype">char</span> *tag, int32 bound)
01198         {
01199             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a37">retrieveParentTagLength</a>(tag, bound));
01200         }
01201 
01205         <span class="keywordtype">void</span> makeValidTag(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn, MMAuditCharAutoPtr&amp; autoptr)
01206         {
01207             (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a38">makeValidTag</a>(tagIn, autoptr));
01208         }
01209 
01213         uint32 getTagActualSize(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
01214         {
01215             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a39">getTagActualSize</a>(tagIn));
01216         }
01217 
01221         <span class="keywordtype">bool</span> isSetFailure(<span class="keyword">const</span> <span class="keywordtype">char</span> * tagIn)
01222         {
01223             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a40">isSetFailure</a>(tagIn));
01224         }
01225 
01226         <span class="keywordtype">bool</span> isSetFailure(<a class="code" href="classOsclMemStatsNode.html">OsclMemStatsNode</a> * statsNode)
01227         {
01228             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a40">isSetFailure</a>(statsNode));
01229         }
01230 
01234         <span class="keywordtype">bool</span> validate(<span class="keywordtype">void</span> *ptrIn)
01235         {
01236             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#d0">validate</a>(ptrIn));
01237         }
01238 
01242         <span class="keywordtype">bool</span> validate_all_heap()
01243         {
01244             <span class="keywordflow">return</span> (_pMM_Audit_Imp-&gt;<a class="code" href="classMM__Audit__Imp.html#a42">validate_all_heap</a>());
01245         }
01246 
01247 
01248     <span class="keyword">private</span>:
01249 
01250         <span class="comment">/*</span>
01251 <span class="comment">        * The following are private data members</span>
01252 <span class="comment">        */</span>
01253 
01254         <a class="code" href="classMM__Audit__Imp.html">MM_Audit_Imp</a> *_pMM_Audit_Imp;
01255         <a class="code" href="classOsclLockBase.html">OsclLockBase</a> *iLock;
01256 
01260         _OsclBasicLock iSingletonLock;
01261         int32 iRefCount;
<a name="l01262"></a><a class="code" href="classOsclMemAudit.html#l0">01262</a>         <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classOsclMemGlobalAuditObject.html">OsclMemGlobalAuditObject</a>;
01263 
01264 };
01265 <span class="preprocessor">#endif</span>
01266 <span class="preprocessor"></span>
01267 <span class="preprocessor">#endif //OSCL_MEM_AUDIT_H_INCLUDED</span>
01268 <span class="preprocessor"></span>
</pre></div><hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: OPENCORE_20090310 </small>
</small></address>
</body>
</html>
