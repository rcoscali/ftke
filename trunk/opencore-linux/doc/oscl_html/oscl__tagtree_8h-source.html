<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>oscl_tagtree.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>oscl_tagtree.h</h1><a href="oscl__tagtree_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">// -*- c++ -*-</span>
00002 <span class="comment">// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</span>
00003 
00004 <span class="comment">//                     O S C L _ T A G T R E E</span>
00005 
00006 <span class="comment">// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = =</span>
00007 
00018 <span class="preprocessor">#ifndef OSCL_TAGTREE_H_INCLUDED</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define OSCL_TAGTREE_H_INCLUDED</span>
00020 <span class="preprocessor"></span>
00021 <span class="preprocessor">#ifndef OSCL_BASE_H_INCLUDED</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__base_8h.html">oscl_base.h</a>"</span>
00023 <span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#ifndef OSCL_MAP_H_INCLUDED</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__map_8h.html">oscl_map.h</a>"</span>
00027 <span class="preprocessor">#endif</span>
00028 <span class="preprocessor"></span>
00029 <span class="preprocessor">#ifndef OSCL_VECTOR_H_INCLUDED</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__vector_8h.html">oscl_vector.h</a>"</span>
00031 <span class="preprocessor">#endif</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#ifndef OSCL_STDSTRING_H_INCLUDED</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="oscl__stdstring_8h.html">oscl_stdstring.h</a>"</span>
00035 <span class="preprocessor">#endif</span>
00036 <span class="preprocessor"></span>
<a name="l00037"></a><a class="code" href="oscl__tagtree_8h.html#a0">00037</a> <span class="preprocessor">#define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#include "<a class="code" href="osclconfig__compiler__warnings_8h.html">osclconfig_compiler_warnings.h</a>"</span>
00039 
00040 
<a name="l00041"></a><a class="code" href="structOscl__Tag__Base.html">00041</a> <span class="keyword">struct </span><a class="code" href="structOscl__Tag__Base.html">Oscl_Tag_Base</a>
00042 {
<a name="l00043"></a><a class="code" href="structOscl__Tag__Base.html#s0">00043</a>     <span class="keyword">typedef</span> <span class="keywordtype">char</span> <a class="code" href="structOscl__Tag__Base.html#s0">tag_base_unit</a>;
<a name="l00044"></a><a class="code" href="structOscl__Tag__Base.html#s1">00044</a>     <span class="keyword">typedef</span> <a class="code" href="structOscl__Tag__Base.html#s0">tag_base_unit</a>* <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>;
<a name="l00045"></a><a class="code" href="structOscl__Tag__Base.html#s2">00045</a>     <span class="keyword">typedef</span> uint32 <a class="code" href="structOscl__Tag__Base.html#s2">size_type</a>;
00046 
<a name="l00047"></a><a class="code" href="structOscl__Tag__Base.html#a0">00047</a>     <span class="keywordtype">bool</span> <a class="code" href="structOscl__Tag__Base.html#a0">operator()</a>(<span class="keyword">const</span> <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; x, <span class="keyword">const</span> <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; y)<span class="keyword"> const</span>
00048 <span class="keyword">    </span>{
00049         <span class="keywordflow">return</span> <a class="code" href="structOscl__Tag__Base.html#a3">tag_cmp</a>(x, y) &lt; 0;
00050     }
<a name="l00051"></a><a class="code" href="structOscl__Tag__Base.html#a1">00051</a>     <a class="code" href="structOscl__Tag__Base.html#s2">size_type</a> <a class="code" href="structOscl__Tag__Base.html#a1">tag_len</a>(<span class="keyword">const</span> <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; t)<span class="keyword"> const</span>
00052 <span class="keyword">    </span>{
00053         <span class="keywordflow">return</span> (size_type)<a class="code" href="group__osclbase.html#a43">oscl_strlen</a>(t);
00054     }
<a name="l00055"></a><a class="code" href="structOscl__Tag__Base.html#a2">00055</a>     <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a> <a class="code" href="structOscl__Tag__Base.html#a2">tag_copy</a>(<a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; dest, <span class="keyword">const</span> <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; src)<span class="keyword"> const</span>
00056 <span class="keyword">    </span>{
00057         <span class="keywordflow">return</span> <a class="code" href="group__osclbase.html#a45">oscl_strncpy</a>(dest, src, <a class="code" href="group__osclbase.html#a43">oscl_strlen</a>(src) + 1);
00058     }
<a name="l00059"></a><a class="code" href="structOscl__Tag__Base.html#a3">00059</a>     int32 <a class="code" href="structOscl__Tag__Base.html#a3">tag_cmp</a>(<span class="keyword">const</span> <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; x, <span class="keyword">const</span> <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; y)<span class="keyword"> const</span>
00060 <span class="keyword">    </span>{
00061         <span class="keywordflow">return</span> <a class="code" href="group__osclbase.html#a49">oscl_strncmp</a>(x, y, <a class="code" href="group__osclbase.html#a43">oscl_strlen</a>(x) + 1);
00062     }
00063     OSCL_IMPORT_REF <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a> <a class="code" href="structOscl__Tag__Base.html#a4">tag_ancestor</a>(<a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; dest, <span class="keyword">const</span> <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; src) <span class="keyword">const</span>;
00064     OSCL_IMPORT_REF <a class="code" href="structOscl__Tag__Base.html#s2">size_type</a> <a class="code" href="structOscl__Tag__Base.html#a5">tag_depth</a>(<span class="keyword">const</span> <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; t) <span class="keyword">const</span>;
00065 };
00066 
00067 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Alloc&gt;
<a name="l00068"></a><a class="code" href="structOscl__Tag.html">00068</a> <span class="keyword">struct </span><a class="code" href="structOscl__Tag.html">Oscl_Tag</a> : <span class="keyword">public</span> <a class="code" href="structOscl__Tag__Base.html">Oscl_Tag_Base</a>
00069 {
00070 
<a name="l00071"></a><a class="code" href="structOscl__Tag.html#a0">00071</a>     <a class="code" href="structOscl__Tag.html#a0">Oscl_Tag</a>(<span class="keyword">const</span> <a class="code" href="structOscl__Tag.html">Oscl_Tag&lt;Alloc&gt;</a>&amp; t)
00072     {
00073         <a class="code" href="structOscl__Tag.html#m1">tag</a> = <a class="code" href="structOscl__Tag.html#m0">tagAllocator</a>.ALLOCATE(<a class="code" href="structOscl__Tag__Base.html#a1">tag_len</a>(t.<a class="code" href="structOscl__Tag.html#m1">tag</a>) + 1);
00074         <a class="code" href="structOscl__Tag__Base.html#a2">tag_copy</a>(<a class="code" href="structOscl__Tag.html#m1">tag</a>, t.<a class="code" href="structOscl__Tag.html#m1">tag</a>);
00075     }
00076 
<a name="l00077"></a><a class="code" href="structOscl__Tag.html#a1">00077</a>     <a class="code" href="structOscl__Tag.html#a0">Oscl_Tag</a>(<span class="keyword">const</span> <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a>&amp; t)
00078     {
00079         <a class="code" href="structOscl__Tag.html#m1">tag</a> = <a class="code" href="structOscl__Tag.html#m0">tagAllocator</a>.ALLOCATE(<a class="code" href="structOscl__Tag__Base.html#a1">tag_len</a>(t) + 1);
00080         <a class="code" href="structOscl__Tag__Base.html#a2">tag_copy</a>(<a class="code" href="structOscl__Tag.html#m1">tag</a>, t);
00081     }
00082 
<a name="l00083"></a><a class="code" href="structOscl__Tag.html#a2">00083</a>     <a class="code" href="structOscl__Tag.html#a2">~Oscl_Tag</a>()
00084     {
00085         <a class="code" href="structOscl__Tag.html#m0">tagAllocator</a>.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>(<a class="code" href="structOscl__Tag.html#m1">tag</a>);
00086     }
00087 
<a name="l00088"></a><a class="code" href="structOscl__Tag.html#a3">00088</a>     <span class="keywordtype">bool</span> operator&lt;(const Oscl_Tag&lt;Alloc&gt;&amp; x) <span class="keyword">const</span>
00089     {
00090         <span class="keywordflow">return</span> (<a class="code" href="structOscl__Tag__Base.html#a3">tag_cmp</a>(<a class="code" href="structOscl__Tag.html#m1">tag</a>, x.tag) &lt; 0);
00091     }
00092 
<a name="l00093"></a><a class="code" href="structOscl__Tag.html#m0">00093</a>     <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;tag_base_unit, Alloc&gt;</a> <a class="code" href="structOscl__Tag.html#m0">tagAllocator</a>;
<a name="l00094"></a><a class="code" href="structOscl__Tag.html#m1">00094</a>     <a class="code" href="structOscl__Tag__Base.html#s1">tag_base_type</a> <a class="code" href="structOscl__Tag.html#m1">tag</a>;
00095 };
00096 
00100 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l00101"></a><a class="code" href="classOscl__TagTree.html">00101</a> <span class="keyword">class </span><a class="code" href="classOscl__TagTree.html">Oscl_TagTree</a>
00102 {
00103 
00104     <span class="keyword">public</span>:
<a name="l00105"></a><a class="code" href="classOscl__TagTree.html#s0">00105</a>         <span class="keyword">typedef</span> <a class="code" href="structOscl__Tag.html">Oscl_Tag&lt;Alloc&gt;</a> <a class="code" href="structOscl__Tag.html">tag_type</a>;
<a name="l00106"></a><a class="code" href="classOscl__TagTree.html#s1">00106</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> tag_type::tag_base_type <a class="code" href="classOscl__TagTree.html#s1">tag_base_type</a>;
00107 
00108 
<a name="l00109"></a><a class="code" href="structOscl__TagTree_1_1Node.html">00109</a>         <span class="keyword">struct </span><a class="code" href="structOscl__TagTree_1_1Node.html">Node</a>
00110         {
<a name="l00111"></a><a class="code" href="structOscl__TagTree_1_1Node.html#s0">00111</a>             <span class="keyword">typedef</span> <a class="code" href="classOscl__Vector.html">Oscl_Vector&lt;Node*, Alloc&gt;</a> <a class="code" href="classOscl__Vector.html">children_type</a>;
<a name="l00112"></a><a class="code" href="structOscl__TagTree_1_1Node.html#a0">00112</a>             <a class="code" href="structOscl__TagTree_1_1Node.html#a0">Node</a>() {}
00113 
<a name="l00114"></a><a class="code" href="structOscl__TagTree_1_1Node.html#m0">00114</a>             tag_type <a class="code" href="structOscl__TagTree_1_1Node.html#m0">tag</a>;
<a name="l00115"></a><a class="code" href="structOscl__TagTree_1_1Node.html#m1">00115</a>             T <a class="code" href="structOscl__TagTree_1_1Node.html#m1">value</a>;
<a name="l00116"></a><a class="code" href="structOscl__TagTree_1_1Node.html#m2">00116</a>             <a class="code" href="structOscl__TagTree_1_1Node.html">Node</a>* <a class="code" href="structOscl__TagTree_1_1Node.html#m2">parent</a>;
<a name="l00117"></a><a class="code" href="structOscl__TagTree_1_1Node.html#m3">00117</a>             children_type <a class="code" href="structOscl__TagTree_1_1Node.html#m3">children</a>;
00118 
<a name="l00119"></a><a class="code" href="structOscl__TagTree_1_1Node.html#a1">00119</a>             <span class="keywordtype">void</span> <a class="code" href="structOscl__TagTree_1_1Node.html#a1">sort_children</a>()
00120             {
00121                 <span class="keywordtype">bool</span> tryagain;
00122                 <span class="keywordflow">if</span> (children.<a class="code" href="classOscl__Vector__Base.html#a2">empty</a>()) <span class="keywordflow">return</span>;
00123                 <span class="keywordflow">do</span>
00124                 {
00125                     tryagain = 0;
00126                     <span class="keywordflow">for</span> (<span class="keyword">typename</span> children_type::iterator it = children.<a class="code" href="classOscl__Vector.html#a17">begin</a>(); it != (children.<a class="code" href="classOscl__Vector.html#a18">end</a>() - 1); it++)
00127                     {
00128                         <span class="keyword">typename</span> children_type::iterator it2 = it + 1;
00129                         <span class="keywordflow">if</span> ((*it2)-&gt;tag &lt; (*it)-&gt;tag)
00130                         {
00131                             <span class="comment">// swap em</span>
00132                             <a class="code" href="structOscl__TagTree_1_1Node.html">Node</a>* tmp = *it;
00133                             *it = *it2;
00134                             *it2 = tmp;
00135                             tryagain = 1;
00136                         }
00137                     }
00138                 }
00139                 <span class="keywordflow">while</span> (tryagain);
00140             }
00141 
<a name="l00142"></a><a class="code" href="structOscl__TagTree_1_1Node.html#a2">00142</a>             <span class="keyword">typename</span> tag_type::size_type <a class="code" href="structOscl__TagTree_1_1Node.html#a2">depth</a>()
00143             {
00144                 <span class="keywordflow">return</span> tag.<a class="code" href="structOscl__Tag__Base.html#a5">tag_depth</a>(tag.<a class="code" href="structOscl__Tag.html#m1">tag</a>);
00145             }
00146         };
00147 
<a name="l00148"></a><a class="code" href="classOscl__TagTree.html#s2">00148</a>         <span class="keyword">typedef</span> <a class="code" href="classOscl__Vector.html">Oscl_Vector&lt;Node*, Alloc&gt;</a> <a class="code" href="classOscl__Vector.html">children_type</a>;
00149 
<a name="l00150"></a><a class="code" href="classOscl__TagTree.html#s3">00150</a>         <span class="keyword">typedef</span> Node <a class="code" href="classOscl__TagTree.html#s3">node_type</a>;
<a name="l00151"></a><a class="code" href="classOscl__TagTree.html#s4">00151</a>         <span class="keyword">typedef</span> <a class="code" href="classOscl__TagTree.html#s3">node_type</a>* <a class="code" href="classOscl__TagTree.html#s4">node_ptr</a>;
<a name="l00152"></a><a class="code" href="classOscl__TagTree.html#s5">00152</a>         <span class="keyword">typedef</span> <a class="code" href="classOscl__Map.html">Oscl_Map&lt;const tag_base_type, node_ptr, Alloc , Oscl_Tag_Base&gt;</a> <a class="code" href="classOscl__Map.html">map_type</a>;
<a name="l00153"></a><a class="code" href="classOscl__TagTree.html#s6">00153</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> map_type::size_type <a class="code" href="classOscl__TagTree.html#s6">size_type</a>;
<a name="l00154"></a><a class="code" href="classOscl__TagTree.html#s7">00154</a>         <span class="keyword">typedef</span> <span class="keyword">typename</span> map_type::value_type <a class="code" href="classOscl__TagTree.html#s7">value_type</a>;
00155 
<a name="l00156"></a><a class="code" href="structOscl__TagTree_1_1iterator.html">00156</a>         <span class="keyword">struct </span><a class="code" href="structOscl__TagTree_1_1iterator.html">iterator</a>
00157         {
<a name="l00158"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#s0">00158</a>             <span class="keyword">typedef</span> <a class="code" href="structOscl__TagTree_1_1Node.html">node_type</a>&amp; <a class="code" href="structOscl__TagTree_1_1iterator.html#s0">reference</a>;
<a name="l00159"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#s1">00159</a>             <span class="keyword">typedef</span> <a class="code" href="structOscl__TagTree_1_1Node.html">node_type</a>* <a class="code" href="structOscl__TagTree_1_1iterator.html#s1">pointer</a>;
<a name="l00160"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#s2">00160</a>             <span class="keyword">typedef</span> <span class="keyword">typename</span> map_type::iterator <a class="code" href="structOscl__TagTree_1_1iterator.html#s2">mapiter</a>;
<a name="l00161"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#s3">00161</a>             <span class="keyword">typedef</span> <a class="code" href="structOscl__TagTree_1_1iterator.html">iterator</a> <a class="code" href="structOscl__TagTree_1_1iterator.html#s3">self</a>;
00162 
<a name="l00163"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a0">00163</a>             <a class="code" href="structOscl__TagTree_1_1iterator.html#a0">iterator</a>() {}
<a name="l00164"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a1">00164</a>             <a class="code" href="structOscl__TagTree_1_1iterator.html#a0">iterator</a>(<a class="code" href="structOscl__TagTree_1_1iterator.html#s2">mapiter</a> x)
00165             {
00166                 <a class="code" href="structOscl__TagTree_1_1iterator.html#m0">mapit</a> = x;
00167             }
<a name="l00168"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a2">00168</a>             <a class="code" href="structOscl__TagTree_1_1iterator.html#a0">iterator</a>(<span class="keyword">const</span> <a class="code" href="structOscl__TagTree_1_1iterator.html">iterator</a>&amp; it)
00169             {
00170                 <a class="code" href="structOscl__TagTree_1_1iterator.html#m0">mapit</a> = it.<a class="code" href="structOscl__TagTree_1_1iterator.html#m0">mapit</a>;
00171             }
00172 
<a name="l00173"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a3">00173</a>             reference <a class="code" href="structOscl__TagTree_1_1iterator.html#a3">operator*</a>()<span class="keyword"> const</span>
00174 <span class="keyword">            </span>{
00175                 <span class="keywordflow">return</span> *((*mapit).second);
00176             }
<a name="l00177"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a4">00177</a>             pointer <a class="code" href="structOscl__TagTree_1_1iterator.html#a4">operator-&gt;</a>()<span class="keyword"> const</span>
00178 <span class="keyword">            </span>{
00179                 <span class="keywordflow">return</span> &amp;(<a class="code" href="structOscl__TagTree_1_1iterator.html#a3">operator*</a>());
00180             }
00181 
<a name="l00182"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a5">00182</a>             <span class="keywordtype">bool</span> <a class="code" href="structOscl__TagTree_1_1iterator.html#a5">operator==</a>(<span class="keyword">const</span> self&amp; x)
00183             {
00184                 <span class="keywordflow">return</span> <a class="code" href="structOscl__TagTree_1_1iterator.html#m0">mapit</a> == x.mapit;
00185             }
00186 
<a name="l00187"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a6">00187</a>             <span class="keywordtype">bool</span> <a class="code" href="structOscl__TagTree_1_1iterator.html#a6">operator!=</a>(<span class="keyword">const</span> self&amp; x)
00188             {
00189                 <span class="keywordflow">return</span> <a class="code" href="structOscl__TagTree_1_1iterator.html#m0">mapit</a> != x.mapit;
00190             }
00191 
<a name="l00192"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a7">00192</a>             self&amp; <a class="code" href="structOscl__TagTree_1_1iterator.html#a7">operator++</a>()
00193             {
00194                 <a class="code" href="structOscl__TagTree_1_1iterator.html#m0">mapit</a>++;
00195                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00196             }
00197 
<a name="l00198"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a8">00198</a>             self <a class="code" href="structOscl__TagTree_1_1iterator.html#a7">operator++</a>(<span class="keywordtype">int</span>)
00199             {
00200                 self tmp = *<span class="keyword">this</span>;
00201                 ++*<span class="keyword">this</span>;
00202                 <span class="keywordflow">return</span> tmp;
00203             }
00204 
<a name="l00205"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a9">00205</a>             self&amp; <a class="code" href="structOscl__TagTree_1_1iterator.html#a9">operator--</a>()
00206             {
00207                 <a class="code" href="structOscl__TagTree_1_1iterator.html#m0">mapit</a>--;
00208                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00209             }
00210 
<a name="l00211"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#a10">00211</a>             self <a class="code" href="structOscl__TagTree_1_1iterator.html#a9">operator--</a>(<span class="keywordtype">int</span>)
00212             {
00213                 self tmp = *<span class="keyword">this</span>;
00214                 --*<span class="keyword">this</span>;
00215                 <span class="keywordflow">return</span> tmp;
00216             }
00217 
<a name="l00218"></a><a class="code" href="structOscl__TagTree_1_1iterator.html#m0">00218</a>             <a class="code" href="structOscl__TagTree_1_1iterator.html#s2">mapiter</a> <a class="code" href="structOscl__TagTree_1_1iterator.html#m0">mapit</a>;
00219         };
00220 
<a name="l00221"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html">00221</a>         <span class="keyword">struct </span><a class="code" href="structOscl__TagTree_1_1const__iterator.html">const_iterator</a>
00222         {
<a name="l00223"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#s0">00223</a>             <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="structOscl__TagTree_1_1Node.html">node_type</a>&amp; <a class="code" href="structOscl__TagTree_1_1const__iterator.html#s0">reference</a>;
<a name="l00224"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#s1">00224</a>             <span class="keyword">typedef</span> <span class="keyword">const</span> <a class="code" href="structOscl__TagTree_1_1Node.html">node_type</a>* <a class="code" href="structOscl__TagTree_1_1const__iterator.html#s1">pointer</a>;
<a name="l00225"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#s2">00225</a>             <span class="keyword">typedef</span> <span class="keyword">typename</span> map_type::const_iterator <a class="code" href="structOscl__TagTree_1_1const__iterator.html#s2">mapiter</a>;
<a name="l00226"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#s3">00226</a>             <span class="keyword">typedef</span> <a class="code" href="structOscl__TagTree_1_1const__iterator.html">const_iterator</a> <a class="code" href="structOscl__TagTree_1_1const__iterator.html#s3">self</a>;
00227 
<a name="l00228"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a0">00228</a>             <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a0">const_iterator</a>() {}
<a name="l00229"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a1">00229</a>             <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a0">const_iterator</a>(<a class="code" href="structOscl__TagTree_1_1const__iterator.html#s2">mapiter</a> x)
00230             {
00231                 <a class="code" href="structOscl__TagTree_1_1const__iterator.html#m0">mapit</a> = x;
00232             }
<a name="l00233"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a2">00233</a>             <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a0">const_iterator</a>(<span class="keyword">const</span> <a class="code" href="structOscl__TagTree_1_1const__iterator.html">const_iterator</a>&amp; it)
00234             {
00235                 <a class="code" href="structOscl__TagTree_1_1const__iterator.html#m0">mapit</a> = it.<a class="code" href="structOscl__TagTree_1_1const__iterator.html#m0">mapit</a>;
00236             }
00237 
<a name="l00238"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a3">00238</a>             reference <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a3">operator*</a>()<span class="keyword"> const</span>
00239 <span class="keyword">            </span>{
00240                 <span class="keywordflow">return</span> *((*mapit).second);
00241             }
<a name="l00242"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a4">00242</a>             pointer <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a4">operator-&gt;</a>()<span class="keyword"> const</span>
00243 <span class="keyword">            </span>{
00244                 <span class="keywordflow">return</span> &amp;(<a class="code" href="structOscl__TagTree_1_1const__iterator.html#a3">operator*</a>());
00245             }
00246 
<a name="l00247"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a5">00247</a>             <span class="keywordtype">bool</span> <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a5">operator==</a>(<span class="keyword">const</span> self&amp; x)
00248             {
00249                 <span class="keywordflow">return</span> <a class="code" href="structOscl__TagTree_1_1const__iterator.html#m0">mapit</a> == x.mapit;
00250             }
00251 
<a name="l00252"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a6">00252</a>             <span class="keywordtype">bool</span> <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a6">operator!=</a>(<span class="keyword">const</span> self&amp; x)
00253             {
00254                 <span class="keywordflow">return</span> <a class="code" href="structOscl__TagTree_1_1const__iterator.html#m0">mapit</a> != x.mapit;
00255             }
00256 
<a name="l00257"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a7">00257</a>             self&amp; <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a7">operator++</a>()
00258             {
00259                 <a class="code" href="structOscl__TagTree_1_1const__iterator.html#m0">mapit</a>++;
00260                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00261             }
00262 
<a name="l00263"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a8">00263</a>             self <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a7">operator++</a>(<span class="keywordtype">int</span>)
00264             {
00265                 self tmp = *<span class="keyword">this</span>;
00266                 ++*<span class="keyword">this</span>;
00267                 <span class="keywordflow">return</span> tmp;
00268             }
00269 
<a name="l00270"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a9">00270</a>             self&amp; <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a9">operator--</a>()
00271             {
00272                 <a class="code" href="structOscl__TagTree_1_1const__iterator.html#m0">mapit</a>--;
00273                 <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00274             }
00275 
<a name="l00276"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#a10">00276</a>             self <a class="code" href="structOscl__TagTree_1_1const__iterator.html#a9">operator--</a>(<span class="keywordtype">int</span>)
00277             {
00278                 self tmp = *<span class="keyword">this</span>;
00279                 --*<span class="keyword">this</span>;
00280                 <span class="keywordflow">return</span> tmp;
00281             }
00282 
<a name="l00283"></a><a class="code" href="structOscl__TagTree_1_1const__iterator.html#m0">00283</a>             <a class="code" href="structOscl__TagTree_1_1const__iterator.html#s2">mapiter</a> <a class="code" href="structOscl__TagTree_1_1const__iterator.html#m0">mapit</a>;
00284         };
00285 
00286     <span class="keyword">public</span>:
00287 
<a name="l00291"></a><a class="code" href="classOscl__TagTree.html#a0">00291</a>         <a class="code" href="classOscl__TagTree.html#a0">Oscl_TagTree</a>(<a class="code" href="classOscl__TagTree.html#s6">size_type</a> max_depth = 0) : maxDepth(max_depth)
00292         {
00293             <span class="comment">// insert the root node</span>
00294             <a class="code" href="classOscl__TagTree.html#s4">node_ptr</a> node = create_node((<span class="keywordtype">char</span>*)<span class="stringliteral">""</span>, T());
00295             node-&gt;parent = <a class="code" href="group__osclbase.html#a81">NULL</a>;
00296             <span class="keyword">typename</span> map_type::value_type pair(node-&gt;tag.tag, node);
00297             nodeMap.<a class="code" href="classOscl__Map.html#a13">insert</a>(pair);
00298         }
<a name="l00302"></a><a class="code" href="classOscl__TagTree.html#a1">00302</a>         <a class="code" href="classOscl__TagTree.html#a0">Oscl_TagTree</a>(<span class="keyword">const</span> <a class="code" href="classOscl__TagTree.html">Oscl_TagTree&lt;T, Alloc&gt;</a>&amp; x) : maxDepth(x.maxDepth)
00303         {
00304             <span class="keywordflow">for</span> (const_iterator it = x.begin(); it != x.end(); it++)
00305             {
00306                 <a class="code" href="classOscl__TagTree.html#a11">insert</a>(it-&gt;tag.tag, it-&gt;value);
00307             }
00308         }
<a name="l00312"></a><a class="code" href="classOscl__TagTree.html#a2">00312</a>         <a class="code" href="classOscl__TagTree.html">Oscl_TagTree&lt;T, Alloc&gt;</a>&amp; <a class="code" href="classOscl__TagTree.html#a2">operator=</a>(<span class="keyword">const</span> <a class="code" href="classOscl__TagTree.html">Oscl_TagTree&lt;T, Alloc&gt;</a>&amp; x)
00313         {
00314             maxDepth = x.<a class="code" href="classOscl__TagTree.html#o2">maxDepth</a>;
00315             <span class="comment">// clear the current tree</span>
00316             <a class="code" href="classOscl__TagTree.html#a14">clear</a>();
00317             <span class="comment">// insert nodes from assigned tree</span>
00318             <span class="keywordflow">for</span> (const_iterator it = x.<a class="code" href="classOscl__TagTree.html#a4">begin</a>(); it != x.<a class="code" href="classOscl__TagTree.html#a6">end</a>(); it++)
00319             {
00320                 <a class="code" href="classOscl__TagTree.html#a11">insert</a>(it-&gt;tag.tag, it-&gt;value);
00321             }
00322             <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00323         }
<a name="l00327"></a><a class="code" href="classOscl__TagTree.html#a3">00327</a>         <a class="code" href="classOscl__TagTree.html#a3">~Oscl_TagTree</a>()
00328         {
00329             <span class="comment">// destroy all nodes stored in the map</span>
00330             <span class="keywordflow">for</span> (iterator it = <a class="code" href="classOscl__TagTree.html#a4">begin</a>(); it != <a class="code" href="classOscl__TagTree.html#a6">end</a>(); it++)
00331             {
00332                 destroy_node(&amp;(*it));
00333             }
00334         }
<a name="l00338"></a><a class="code" href="classOscl__TagTree.html#a4">00338</a>         iterator <a class="code" href="classOscl__TagTree.html#a4">begin</a>()
00339         {
00340             <span class="keywordflow">return</span> iterator(nodeMap.<a class="code" href="classOscl__Map.html#a5">begin</a>());
00341         }
<a name="l00345"></a><a class="code" href="classOscl__TagTree.html#a5">00345</a>         const_iterator <a class="code" href="classOscl__TagTree.html#a4">begin</a>()<span class="keyword"> const</span>
00346 <span class="keyword">        </span>{
00347             <span class="keywordflow">return</span> const_iterator(nodeMap.<a class="code" href="classOscl__Map.html#a5">begin</a>());
00348         }
<a name="l00352"></a><a class="code" href="classOscl__TagTree.html#a6">00352</a>         iterator <a class="code" href="classOscl__TagTree.html#a6">end</a>()
00353         {
00354             <span class="keywordflow">return</span> iterator(nodeMap.<a class="code" href="classOscl__Map.html#a7">end</a>());
00355         }
<a name="l00359"></a><a class="code" href="classOscl__TagTree.html#a7">00359</a>         const_iterator <a class="code" href="classOscl__TagTree.html#a6">end</a>()<span class="keyword"> const</span>
00360 <span class="keyword">        </span>{
00361             <span class="keywordflow">return</span> const_iterator(nodeMap.<a class="code" href="classOscl__Map.html#a7">end</a>());
00362         }
<a name="l00366"></a><a class="code" href="classOscl__TagTree.html#a8">00366</a>         <span class="keywordtype">bool</span> <a class="code" href="classOscl__TagTree.html#a8">empty</a>()<span class="keyword"> const</span>
00367 <span class="keyword">        </span>{
00368             <span class="keywordflow">return</span> nodeMap.<a class="code" href="classOscl__Map.html#a9">empty</a>();
00369         }
<a name="l00373"></a><a class="code" href="classOscl__TagTree.html#a9">00373</a>         <a class="code" href="classOscl__TagTree.html#s6">size_type</a> <a class="code" href="classOscl__TagTree.html#a9">size</a>()<span class="keyword"> const</span>
00374 <span class="keyword">        </span>{
00375             <span class="keywordflow">return</span> nodeMap.<a class="code" href="classOscl__Map.html#a10">size</a>();
00376         }
<a name="l00381"></a><a class="code" href="classOscl__TagTree.html#a10">00381</a>         T&amp; <a class="code" href="classOscl__TagTree.html#a10">operator[]</a>(<span class="keyword">const</span> <a class="code" href="classOscl__TagTree.html#s1">tag_base_type</a>&amp; t)
00382         {
00383             <span class="keywordflow">return</span> (*((<a class="code" href="classOscl__TagTree.html#a11">insert</a>(t, T())).first)).value;
00384         }
00385 
<a name="l00386"></a><a class="code" href="classOscl__TagTree.html#s8">00386</a>         <span class="keyword">typedef</span> <a class="code" href="structOscl__Pair.html">Oscl_Pair&lt;iterator, bool&gt;</a> <a class="code" href="structOscl__Pair.html">pair_iterator_bool</a>;
<a name="l00402"></a><a class="code" href="classOscl__TagTree.html#a11">00402</a>         pair_iterator_bool <a class="code" href="classOscl__TagTree.html#a11">insert</a>(<span class="keyword">const</span> <a class="code" href="classOscl__TagTree.html#s1">tag_base_type</a>&amp; t, <span class="keyword">const</span> T&amp; x)
00403         {
00404 
00405             tag_type currenttag(t);
00406             pair_iterator_bool result(<a class="code" href="classOscl__TagTree.html#a6">end</a>(), <span class="keyword">false</span>);
00407             <a class="code" href="classOscl__TagTree.html#s4">node_ptr</a> child = <a class="code" href="group__osclbase.html#a81">NULL</a>;
00408             <a class="code" href="classOscl__TagTree.html#s6">size_type</a> ii;
00409             <a class="code" href="classOscl__TagTree.html#s6">size_type</a> maxloops;
00410 
00411             <span class="comment">// if it exceeds the max depth, then truncate it to the max depth size</span>
00412             <span class="keywordflow">if</span> (maxDepth &gt; 0 &amp;&amp; currenttag.<a class="code" href="structOscl__Tag__Base.html#a5">tag_depth</a>(currenttag.<a class="code" href="structOscl__Tag.html#m1">tag</a>) &gt; maxDepth)
00413             {
00414                 maxloops = currenttag.<a class="code" href="structOscl__Tag__Base.html#a5">tag_depth</a>(currenttag.<a class="code" href="structOscl__Tag.html#m1">tag</a>) - maxDepth;
00415                 <span class="keywordflow">for</span> (ii = 0; ii &lt; maxloops; ii++)
00416                 {
00417                     currenttag.<a class="code" href="structOscl__Tag__Base.html#a4">tag_ancestor</a>(currenttag.<a class="code" href="structOscl__Tag.html#m1">tag</a>, currenttag.<a class="code" href="structOscl__Tag.html#m1">tag</a>);
00418                 }
00419             }
00420 
00421             maxloops = currenttag.<a class="code" href="structOscl__Tag__Base.html#a5">tag_depth</a>(currenttag.<a class="code" href="structOscl__Tag.html#m1">tag</a>) + 1;
00422             <span class="keywordflow">for</span> (ii = 0; ii &lt; maxloops; ii++)
00423             {
00424                 <span class="comment">// check if tag already exists; if so then no need to continue creating nodes</span>
00425                 <span class="keyword">typename</span> map_type::iterator mit = nodeMap.<a class="code" href="classOscl__Map.html#a20">find</a>(currenttag.<a class="code" href="structOscl__Tag.html#m1">tag</a>);
00426                 <span class="keywordflow">if</span> (mit != nodeMap.<a class="code" href="classOscl__Map.html#a7">end</a>())
00427                 {
00428                     <span class="comment">// set child parent relationship</span>
00429                     <span class="keywordflow">if</span> (child)
00430                     {
00431                         child-&gt;parent = (*mit).second;
00432                         child-&gt;parent-&gt;children.push_back(child);
00433                     }
00434                     <span class="comment">// if this is the first pass node, then set it for the return value</span>
00435                     <span class="keywordflow">if</span> (result.<a class="code" href="structOscl__Pair.html#m0">first</a> == <a class="code" href="classOscl__TagTree.html#a6">end</a>()) result.<a class="code" href="structOscl__Pair.html#m0">first</a> = iterator(mit);
00436                     <span class="keywordflow">break</span>;
00437                 }
00438                 <span class="comment">// otherwise create a new node, insert it into map, and set parent/child relationship</span>
00439                 <span class="keywordflow">else</span>
00440                 {
00441                     <span class="comment">// insert the new node</span>
00442                     <span class="comment">// first pass sets the node to the given value, all others are default value</span>
00443                     <a class="code" href="classOscl__TagTree.html#s4">node_ptr</a> node;
00444                     <span class="keywordflow">if</span> (result.<a class="code" href="structOscl__Pair.html#m0">first</a> == <a class="code" href="classOscl__TagTree.html#a6">end</a>())
00445                     {
00446                         node = create_node(currenttag.<a class="code" href="structOscl__Tag.html#m1">tag</a>, x);
00447                     }
00448                     <span class="keywordflow">else</span>
00449                     {
00450                         node = create_node(currenttag.<a class="code" href="structOscl__Tag.html#m1">tag</a>, T());
00451                     }
00452 
00453                     <span class="keyword">typename</span> map_type::value_type pair(node-&gt;tag.tag, node);
00454                     <span class="keyword">typename</span> map_type::pair_iterator_bool mapresult = (nodeMap.<a class="code" href="classOscl__Map.html#a13">insert</a>(pair));
00455 
00456                     <span class="comment">// if this is the first pass node to insert, save it for the return value</span>
00457                     <span class="keywordflow">if</span> (result.<a class="code" href="structOscl__Pair.html#m0">first</a> == <a class="code" href="classOscl__TagTree.html#a6">end</a>())
00458                     {
00459                         result.<a class="code" href="structOscl__Pair.html#m0">first</a> = iterator(mapresult.first);
00460                         result.<a class="code" href="structOscl__Pair.html#m1">second</a> = mapresult.second;
00461                     }
00462                     <span class="comment">// set child/parent relationship</span>
00463                     <span class="keywordflow">if</span> (child)
00464                     {
00465                         child-&gt;parent = (*(mapresult.first)).second;
00466                         child-&gt;parent-&gt;children.push_back(child);
00467                     }
00468                     child = node;
00469                 }
00470 
00471                 currenttag.<a class="code" href="structOscl__Tag__Base.html#a4">tag_ancestor</a>(currenttag.<a class="code" href="structOscl__Tag.html#m1">tag</a>, currenttag.<a class="code" href="structOscl__Tag.html#m1">tag</a>);
00472             }
00473 
00474             <span class="keywordflow">return</span> result;
00475         }
<a name="l00484"></a><a class="code" href="classOscl__TagTree.html#a12">00484</a>         <span class="keywordtype">void</span> <a class="code" href="classOscl__TagTree.html#a12">erase</a>(iterator position)
00485         {
00486             <span class="comment">// if node has children, then replace it with default node value</span>
00487             <span class="keywordflow">if</span> (!(position-&gt;children.empty()))
00488             {
00489                 position-&gt;value = T();
00490                 <span class="keywordflow">return</span>;
00491             }
00492 
00493             <span class="comment">// destroy the node since only the pointer is stored</span>
00494             destroy_node(&amp;(*position));
00495             nodeMap.<a class="code" href="classOscl__Map.html#a16">erase</a>(position.mapit);
00496         }
<a name="l00507"></a><a class="code" href="classOscl__TagTree.html#a13">00507</a>         <a class="code" href="classOscl__TagTree.html#s6">size_type</a> <a class="code" href="classOscl__TagTree.html#a12">erase</a>(<span class="keyword">const</span> <a class="code" href="classOscl__TagTree.html#s1">tag_base_type</a>&amp; x)
00508         {
00509             iterator it = <a class="code" href="classOscl__TagTree.html#a15">find</a>(x);
00510             <span class="keywordflow">if</span> (it != <a class="code" href="classOscl__TagTree.html#a6">end</a>())
00511             {
00512                 <a class="code" href="classOscl__TagTree.html#a12">erase</a>(it);
00513                 <span class="keywordflow">return</span> 1;
00514             }
00515             <span class="keywordflow">return</span> 0;
00516         }
<a name="l00520"></a><a class="code" href="classOscl__TagTree.html#a14">00520</a>         <span class="keywordtype">void</span> <a class="code" href="classOscl__TagTree.html#a14">clear</a>()
00521         {
00522             <span class="comment">// destroy all nodes stored in the map</span>
00523             <span class="keywordflow">for</span> (iterator it = <a class="code" href="classOscl__TagTree.html#a4">begin</a>(); it != <a class="code" href="classOscl__TagTree.html#a6">end</a>(); it++)
00524             {
00525                 destroy_node(&amp;(*it));
00526             }
00527             <span class="comment">// clear the map</span>
00528             nodeMap.<a class="code" href="classOscl__Map.html#a19">clear</a>();
00529         }
<a name="l00535"></a><a class="code" href="classOscl__TagTree.html#a15">00535</a>         iterator <a class="code" href="classOscl__TagTree.html#a15">find</a>(<span class="keyword">const</span> <a class="code" href="classOscl__TagTree.html#s1">tag_base_type</a>&amp; x)
00536         {
00537             <span class="keywordflow">return</span> iterator(nodeMap.<a class="code" href="classOscl__Map.html#a20">find</a>(x));
00538         }
00542 <span class="comment">//Removed this version due to ADS 1.2 compile problem</span>
00543 <span class="comment">//    const_iterator find(const tag_base_type&amp; x) const { return const_iterator(nodeMap.find(x)); }</span>
<a name="l00547"></a><a class="code" href="classOscl__TagTree.html#a16">00547</a> <span class="comment"></span>        <a class="code" href="classOscl__TagTree.html#s6">size_type</a> <a class="code" href="classOscl__TagTree.html#a16">count</a>(<span class="keyword">const</span> <a class="code" href="classOscl__TagTree.html#s1">tag_base_type</a>&amp; x)<span class="keyword"> const</span>
00548 <span class="keyword">        </span>{
00549             <span class="keywordflow">return</span> nodeMap.<a class="code" href="classOscl__Map.html#a22">count</a>(x);
00550         }
00551 
00552     <span class="keyword">private</span>:
00553         <a class="code" href="classOscl__TagTree.html#s4">node_ptr</a> create_node(<span class="keyword">const</span> <a class="code" href="classOscl__TagTree.html#s1">tag_base_type</a>&amp; t, <span class="keyword">const</span> T&amp; x)
00554         {
00555             <a class="code" href="classOscl__TagTree.html#s4">node_ptr</a> n = nodeAllocator.ALLOCATE(1);
00556             <span class="keyword">new</span>(&amp;n-&gt;tag) <a class="code" href="classOscl__TagTree.html#s0">tag_type</a>(t);
00557             <span class="keyword">new</span>(&amp;n-&gt;value) T(x);
00558             <span class="keyword">new</span>(&amp;n-&gt;children) <a class="code" href="classOscl__Vector.html">Oscl_Vector&lt;Node*, Alloc&gt;</a>();
00559             <span class="keywordflow">return</span> n;
00560         }
00561 
00562         <span class="keywordtype">void</span> destroy_node(<a class="code" href="classOscl__TagTree.html#s4">node_ptr</a> x)
00563         {
00564             x-&gt;tag.OSCL_TEMPLATED_DESTRUCTOR_CALL(tag_type, <a class="code" href="structOscl__Tag.html">Oscl_Tag</a>);
00565             x-&gt;value.T::~T();
00566             x-&gt;children.OSCL_TEMPLATED_DESTRUCTOR_CALL(children_type, <a class="code" href="classOscl__Vector.html">Oscl_Vector</a>);
00567             nodeAllocator.<a class="code" href="classOscl__TAlloc.html#a5">deallocate</a>(x);
00568         }
00569 
00570         map_type nodeMap;
00571         <a class="code" href="classOscl__TAlloc.html">Oscl_TAlloc&lt;node_type, Alloc&gt;</a> nodeAllocator;
00572         <a class="code" href="classOscl__TagTree.html#s6">size_type</a> maxDepth;
00573 };
00574 
00578 <span class="preprocessor">#endif</span>
00579 <span class="preprocessor"></span>
</pre></div><hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: OPENCORE_20090310 </small>
</small></address>
</body>
</html>
