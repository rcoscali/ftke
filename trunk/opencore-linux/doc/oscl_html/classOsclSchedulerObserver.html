<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OsclSchedulerObserver class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>OsclSchedulerObserver Class Reference<br>
<small>
[<a class="el" href="group__osclproc.html">OSCL Proc</a>]</small>
</h1><code>#include &lt;<a class="el" href="oscl__scheduler_8h-source.html">oscl_scheduler.h</a>&gt;</code>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classOsclSchedulerObserver.html#a0">OsclSchedulerTimerCallback</a> (<a class="el" href="group__osclbase.html#a25">OsclAny</a> *aContext, uint32 aDelayMsec)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual void&nbsp;</td><td valign=bottom><a class="el" href="classOsclSchedulerObserver.html#a1">OsclSchedulerReadyCallback</a> (<a class="el" href="group__osclbase.html#a25">OsclAny</a> *aContext)=0</td></tr>
<tr><td nowrap align=right valign=top>virtual&nbsp;</td><td valign=bottom><a class="el" href="classOsclSchedulerObserver.html#a2">~OsclSchedulerObserver</a> ()</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
OsclSchedulerObserver is an observer class for use when running scheduler in non-blocking mode. The scheduler observer can register for callbacks so it will be notified when it is necessary to run scheduler again. Note: non-blocking mode and scheduler callbacks are not supported on Symbian. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a2" doxytag="OsclSchedulerObserver::~OsclSchedulerObserver"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual OsclSchedulerObserver::~OsclSchedulerObserver </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline, virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a1" doxytag="OsclSchedulerObserver::OsclSchedulerReadyCallback"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void OsclSchedulerObserver::OsclSchedulerReadyCallback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__osclbase.html#a25">OsclAny</a> *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aContext</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
OsclSchedulerReadyCallback is called when the ready queue is updated, meaning an AO is ready to run. Scheduler needs to be run ASAP. Calling context may be any thread, so be careful!
<p>
The current observer is cleared before making the callback, so the observer must call RegisterForCallback again if it wants further notifications.     </td>
  </tr>
</table>
<a name="a0" doxytag="OsclSchedulerObserver::OsclSchedulerTimerCallback"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> virtual void OsclSchedulerObserver::OsclSchedulerTimerCallback </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__osclbase.html#a25">OsclAny</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aContext</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aDelayMsec</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
OsclSchedulerTimerCallback is called when the front of the timer queue is updated. This means the minimum delay has changed and scheduler needs to be run again after aDelayMsec. Calling context is in-thread.
<p>
The current observer is cleared before making the callback, so the observer must call RegisterForCallback again if it wants further notifications.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="oscl__scheduler_8h-source.html">oscl_scheduler.h</a></ul>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: OPENCORE_20090310 </small>
</small></address>
</body>
</html>
