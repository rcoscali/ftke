<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OSCL Memory</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>OSCL Memory</h1><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Files</h2></td></tr>
<tr><td nowrap align=right valign=top>file &nbsp;</td><td valign=bottom><a class="el" href="oscl__mem_8h.html">oscl_mem.h</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This file contains basic memory definitions for common use across platforms.</em></font><br><br></td></tr>

<p>
<tr><td nowrap align=right valign=top>file &nbsp;</td><td valign=bottom><a class="el" href="oscl__mem__audit_8h.html">oscl_mem_audit.h</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This file contains the definition and partial implementation of MM_Audit class.</em></font><br><br></td></tr>

<p>
<tr><td nowrap align=right valign=top>file &nbsp;</td><td valign=bottom><a class="el" href="oscl__mem__audit__internals_8h.html">oscl_mem_audit_internals.h</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This file contains the internal definitions for the mem audit library.</em></font><br><br></td></tr>

<p>
<tr><td nowrap align=right valign=top>file &nbsp;</td><td valign=bottom><a class="el" href="oscl__mem__auto__ptr_8h.html">oscl_mem_auto_ptr.h</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This file defines the oscl_mem_auto_ptr template class. This class is used to avoid any potential memory leaks that may arise while returning from methods in case of error.</em></font><br><br></td></tr>

<p>
<tr><td nowrap align=right valign=top>file &nbsp;</td><td valign=bottom><a class="el" href="oscl__mem__basic__functions_8h.html">oscl_mem_basic_functions.h</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This file contains prototypes for the basic memory functions.</em></font><br><br></td></tr>

<p>
<tr><td nowrap align=right valign=top>file &nbsp;</td><td valign=bottom><a class="el" href="oscl__mem__mempool_8h.html">oscl_mem_mempool.h</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This file contains the definition of memory pool allocators.</em></font><br><br></td></tr>

<p>
<tr><td colspan=2><br><h2>Data Structures</h2></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classallocator.html">allocator</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classallocator.html">allocator</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classHeapBase.html">HeapBase</a></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structMM__AllocBlockFence.html">MM_AllocBlockFence</a></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structMM__AllocBlockHdr.html">MM_AllocBlockHdr</a></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structMM__AllocInfo.html">MM_AllocInfo</a></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structMM__AllocNode.html">MM_AllocNode</a></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structMM__AllocQueryInfo.html">MM_AllocQueryInfo</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classMM__Audit__Imp.html">MM_Audit_Imp</a></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structMM__AuditOverheadStats.html">MM_AuditOverheadStats</a></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structMM__FailInsertParam.html">MM_FailInsertParam</a></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structMM__Stats__CB.html">MM_Stats_CB</a></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structMM__Stats__t.html">MM_Stats_t</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclAuditCB.html">OsclAuditCB</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMem.html">OsclMem</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemAllocator.html">OsclMemAllocator</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemAllocDestructDealloc.html">OsclMemAllocDestructDealloc</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemAllocDestructDealloc.html">OsclMemAllocDestructDealloc</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemAudit.html">OsclMemAudit</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The oscl_auto_ptr class is a template class that defines a pointer like object intended to be assigned an address obtanined (directly or or indirectly) by new. When the oscl_auto_ptr expires, its destructor uses delete to free the memory.</em> <a href="classOSCLMemAutoPtr.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemBasicAllocDestructDealloc.html">OsclMemBasicAllocDestructDealloc</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemBasicAllocDestructDealloc.html">OsclMemBasicAllocDestructDealloc</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemGlobalAuditObject.html">OsclMemGlobalAuditObject</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemPoolFixedChunkAllocator.html">OsclMemPoolFixedChunkAllocator</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemPoolFixedChunkAllocatorObserver.html">OsclMemPoolFixedChunkAllocatorObserver</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemPoolResizableAllocator.html">OsclMemPoolResizableAllocator</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemPoolResizableAllocatorMemoryObserver.html">OsclMemPoolResizableAllocatorMemoryObserver</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemPoolResizableAllocatorObserver.html">OsclMemPoolResizableAllocatorObserver</a></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a></td></tr>
<tr><td colspan=2><br><h2>Defines</h2></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a33">OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE</a></td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a34">OSCL_HAS_GLOBAL_NEW_DELETE</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a35">OSCL_CLEANUP_BASE_CLASS</a>(T)&nbsp;&nbsp;&nbsp;_OSCL_CLEANUP_BASE_CLASS(T)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a36">OSCL_ALLOC_NEW</a>(T_allocator, T, params)&nbsp;&nbsp;&nbsp;new(T_allocator.allocate(1)) T params</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a37">OSCL_TRAP_ALLOC_NEW</a>(T_ptr, T_allocator, T, params)&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(T_allocator.allocate(1),T_allocator.deallocate,T_ptr,T,params)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a38">OSCL_ALLOC_DELETE</a>(ptr, T_allocator, T)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a39">OSCL_MALLOC</a>(count)&nbsp;&nbsp;&nbsp;_oscl_default_audit_malloc(count)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a40">oscl_malloc</a>(a)&nbsp;&nbsp;&nbsp;OSCL_MALLOC(a)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a41">OSCL_DEFAULT_MALLOC</a>(x)&nbsp;&nbsp;&nbsp;OSCL_MALLOC(x)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a42">OSCL_AUDIT_MALLOC</a>(auditCB, count)&nbsp;&nbsp;&nbsp;_oscl_audit_malloc(count, auditCB)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a43">OSCL_CALLOC</a>(num, size)&nbsp;&nbsp;&nbsp;_oscl_default_audit_calloc(num,size)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a44">oscl_calloc</a>(a, b)&nbsp;&nbsp;&nbsp;OSCL_CALLOC(a,b)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a45">OSCL_AUDIT_CALLOC</a>(auditCB, num, size)&nbsp;&nbsp;&nbsp;_oscl_audit_calloc(num,size, auditCB)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a46">OSCL_REALLOC</a>(ptr, new_size)&nbsp;&nbsp;&nbsp;_oscl_default_audit_realloc(ptr,new_size)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a47">oscl_realloc</a>(a, b)&nbsp;&nbsp;&nbsp;OSCL_REALLOC(a,b)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a48">OSCL_AUDIT_REALLOC</a>(auditCB, ptr, new_size)&nbsp;&nbsp;&nbsp;_oscl_audit_realloc(ptr,new_size, auditCB)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a49">OSCL_FREE</a>(ptr)&nbsp;&nbsp;&nbsp;_oscl_audit_free(ptr)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a50">oscl_free</a>(x)&nbsp;&nbsp;&nbsp;OSCL_FREE(x)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a51">OSCL_DEFAULT_FREE</a>(x)&nbsp;&nbsp;&nbsp;OSCL_FREE(x)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a52">OSCL_NEW</a>(T, params)&nbsp;&nbsp;&nbsp;new T params</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a53">OSCL_PLACEMENT_NEW</a>(ptr, constructor)&nbsp;&nbsp;&nbsp;new(ptr) constructor</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a54">OSCL_TRAP_NEW</a>(T_ptr, T, params)&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(_oscl_default_audit_new(sizeof(T)),_oscl_audit_free,T_ptr,T,params)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a55">OSCL_AUDIT_NEW</a>(auditCB, T, params)&nbsp;&nbsp;&nbsp;new(_oscl_audit_new(sizeof(T),auditCB)) T params</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a56">OSCL_TRAP_AUDIT_NEW</a>(T_ptr, auditCB, T, params)&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(_oscl_audit_new(sizeof(T),auditCB),_oscl_audit_free,T_ptr,T,params)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a57">OSCL_DELETE</a>(ptr)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a58">OSCL_AUDIT_ARRAY_NEW</a>(auditCB, T, count)&nbsp;&nbsp;&nbsp;new(_oscl_audit_new(sizeof(T)*(count),auditCB)) T</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a59">OSCL_ARRAY_NEW</a>(T, count)&nbsp;&nbsp;&nbsp;new T[count]</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a60">OSCL_ARRAY_DELETE</a>(ptr)&nbsp;&nbsp;&nbsp;delete [] ptr</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a61">_OSCL_TRAP_NEW</a>(exp, freeFunc, T_ptr, T, params)</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a62">_OSCL_CLEANUP_BASE_CLASS</a>(T)&nbsp;&nbsp;&nbsp;this-&gt;T::~T()</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a63">MM_ALLOC_MAX_QUERY_FILENAME_LEN</a>&nbsp;&nbsp;&nbsp;128</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a64">MM_ALLOC_MAX_QUERY_TAG_LEN</a>&nbsp;&nbsp;&nbsp;64</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a65">MM_AUDIT_VALIDATE_BLOCK</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a66">MM_AUDIT_PREFILL_FLAG</a>&nbsp;&nbsp;&nbsp;0x1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a67">MM_AUDIT_POSTFILL_FLAG</a>&nbsp;&nbsp;&nbsp;0x2</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a68">MM_AUDIT_VALIDATE_ALL_HEAP_FLAG</a>&nbsp;&nbsp;&nbsp;0x4</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a69">MM_AUDIT_VALIDATE_ON_FREE_FLAG</a>&nbsp;&nbsp;&nbsp;0x8</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a70">MM_AUDIT_ALLOC_NODE_ENABLE_FLAG</a>&nbsp;&nbsp;&nbsp;0x10</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a71">MM_AUDIT_SUPPRESS_FILENAME_FLAG</a>&nbsp;&nbsp;&nbsp;0x20</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a72">DEFAULT_MM_AUDIT_MODE</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a73">MM_AUDIT_ALLOC_NODE_SUPPORT</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a74">MM_AUDIT_FENCE_SUPPORT</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a75">MM_AUDIT_INCLUDE_ALL_HEAP_VALIDATION</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a76">MM_AUDIT_FILL_SUPPORT</a>&nbsp;&nbsp;&nbsp;0</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a77">MM_AUDIT_FAILURE_SIMULATION_SUPPORT</a>&nbsp;&nbsp;&nbsp;1</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a78">FENCE_PATTERN</a>&nbsp;&nbsp;&nbsp;0xAA</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a79">MIN_FENCE_SIZE</a>&nbsp;&nbsp;&nbsp;4</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a80">MEM_ALIGN_SIZE</a>&nbsp;&nbsp;&nbsp;8</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a81">COMPUTE_MEM_ALIGN_SIZE</a>(x, y, z)&nbsp;&nbsp;&nbsp;(y+(((x+y)%z) ? (z - (x+y)%z) : 0))</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a82">DEFAULT_PREFILL_PATTERN</a>&nbsp;&nbsp;&nbsp;0x96</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a83">DEFAULT_POSTFILL_PATTERN</a>&nbsp;&nbsp;&nbsp;0x5A</td></tr>
<tr><td nowrap align=right valign=top>#define&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a84">OSCL_DISABLE_WARNING_RETURN_TYPE_NOT_UDT</a></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt; char,<br>
 <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt; char, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a> &gt; &gt;&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a0">MMAuditCharAutoPtr</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt; uint8,<br>
 <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt; uint8, <a class="el" href="class__OsclBasicAllocator.html">_OsclBasicAllocator</a> &gt; &gt;&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a1">MMAuditUint8AutoPtr</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt; <a class="el" href="structMM__AllocNode.html">MM_AllocNode</a>,<br>
 <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt; <a class="el" href="structMM__AllocNode.html">MM_AllocNode</a>,<br>
 <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a> &gt; &gt;&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a2">MM_AllocNodeAutoPtr</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt; <a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>,<br>
 <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt; <a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>,<br>
 <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a> &gt; &gt;&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a3">MM_StatsNodeTagTreeType</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt; <a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>,<br>
 <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt; <a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>,<br>
 <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a> &gt; &gt;&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a4">OsclMemStatsNodeAutoPtr</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt; <a class="el" href="group__osclmemory.html#a3">MM_StatsNodeTagTreeType</a>,<br>
 <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a5">TagTree_Allocator</a></td></tr>
<tr><td nowrap align=right valign=top>typedef <a class="el" href="classOscl__TagTree.html">Oscl_TagTree</a>&lt; <a class="el" href="group__osclmemory.html#a3">MM_StatsNodeTagTreeType</a>,<br>
 <a class="el" href="group__osclmemory.html#a5">TagTree_Allocator</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a6">OsclTagTreeType</a></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top>OSCL_COND_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a7">_oscl_malloc</a> (int32 count)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_COND_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a8">_oscl_calloc</a> (int32 nelems, int32 size)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_COND_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a9">_oscl_realloc</a> (void *src, int32 count)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_COND_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a10">_oscl_free</a> (void *src)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_COND_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a11">oscl_memcpy</a> (void *dest, const void *src, uint32 count)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_COND_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a12">oscl_memmove</a> (void *dest, const void *src, uint32 count)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_COND_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a13">oscl_memmove32</a> (void *dest, const void *src, uint32 count)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_COND_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a14">oscl_memset</a> (void *dest, uint8 val, uint32 count)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_COND_IMPORT_REF int&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a15">oscl_memcmp</a> (const void *buf1, const void *buf2, uint32 count)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_COND_IMPORT_REF <a class="el" href="group__osclbase.html#a27">uint</a>&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a16">oscl_mem_aligned_size</a> (<a class="el" href="group__osclbase.html#a27">uint</a> size)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a17">OsclMemInit</a> (<a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;auditCB)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a18">_oscl_audit_malloc</a> (size_t, <a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;, const char *f=NULL, const int l=0)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a19">_oscl_audit_calloc</a> (size_t, size_t, <a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;, const char *f=NULL, const int l=0)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a20">_oscl_audit_realloc</a> (void *, size_t, <a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;, const char *f=NULL, const int l=0)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a21">_oscl_audit_new</a> (size_t, <a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;, const char *f=NULL, const int l=0)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a22">_oscl_default_audit_malloc</a> (size_t, const char *f=NULL, const int l=0)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a23">_oscl_default_audit_calloc</a> (size_t, size_t, const char *f=NULL, const int l=0)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a24">_oscl_default_audit_realloc</a> (void *, size_t, const char *f=NULL, const int l=0)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a25">_oscl_default_audit_new</a> (size_t, const char *f=NULL, const int l=0)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a26">_oscl_audit_free</a> (void *)</td></tr>
<tr><td nowrap align=right valign=top>void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a27">operator new</a> (size_t aSize, const char *aFile, int aLine)</td></tr>
<tr><td nowrap align=right valign=top>void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a28">operator new</a> (size_t)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a29">operator delete</a> (void *)</td></tr>
<tr><td nowrap align=right valign=top>void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a30">operator new[]</a> (size_t aSize, const char *aFile, int aLine)</td></tr>
<tr><td nowrap align=right valign=top>void *&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a31">operator new[]</a> (size_t aSize)</td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a32">operator delete[]</a> (void *aPtr)</td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td nowrap align=right valign=top>const uint32&nbsp;</td><td valign=bottom><a class="el" href="group__osclmemory.html#a85">ALLOC_NODE_FLAG</a> = 0x80000000</td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a name="a62" doxytag="oscl_mem.h::_OSCL_CLEANUP_BASE_CLASS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define _OSCL_CLEANUP_BASE_CLASS</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;this-&gt;T::~T()
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This macro is used to cleanup the base class in a derived-class constructor just before a leave occurs.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>T:</em>&nbsp;</td><td>
base class name. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a61" doxytag="oscl_mem.h::_OSCL_TRAP_NEW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define _OSCL_TRAP_NEW</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">exp,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>freeFunc,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_ptr,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>params&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>{\
    int32 __err;\
    <a class="code" href="group__osclbase.html#a25">OsclAny</a>*__ptr=exp;\
    <a class="code" href="group__osclerror.html#a47">OSCL_TRY</a>(__err,T_ptr=<span class="keyword">new</span>(__ptr) T params;);\
    <span class="keywordflow">if</span>(__err){\
        freeFunc(__ptr);\
        T_ptr=<a class="code" href="group__osclbase.html#a81">NULL</a>;\
        <a class="code" href="classOsclError.html#d7">OsclError::Leave</a>(__err);\
    }\
}</pre></div>Internal-use macro to catch leaves in constructors. If the constructor leaves, this will free the memory before allowing the leave to propagate to the next level. It is the constructor's responsibility to cleanup any memory in the partially constructed object before leaving. This cleanup may include cleaning up the base class using the OSCL_CLEANUP_BASE_CLASS macro.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>exp:</em>&nbsp;</td><td>
expression to allocate memory. </td></tr>
<tr><td valign=top><em>Tptr:variable</em>&nbsp;</td><td>
to hold result. </td></tr>
<tr><td valign=top><em>T:</em>&nbsp;</td><td>
type </td></tr>
<tr><td valign=top><em>params:</em>&nbsp;</td><td>
constructor arg list </td></tr>
<tr><td valign=top><em>freeFunc:</em>&nbsp;</td><td>
delete or free function. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a81" doxytag="oscl_mem_audit_internals.h::COMPUTE_MEM_ALIGN_SIZE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define COMPUTE_MEM_ALIGN_SIZE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>y,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>z&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;(y+(((x+y)%z) ? (z - (x+y)%z) : 0))
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a72" doxytag="oscl_mem_audit.h::DEFAULT_MM_AUDIT_MODE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DEFAULT_MM_AUDIT_MODE&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a83" doxytag="oscl_mem_audit_internals.h::DEFAULT_POSTFILL_PATTERN"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DEFAULT_POSTFILL_PATTERN&nbsp;&nbsp;&nbsp;0x5A
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a82" doxytag="oscl_mem_audit_internals.h::DEFAULT_PREFILL_PATTERN"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define DEFAULT_PREFILL_PATTERN&nbsp;&nbsp;&nbsp;0x96
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a78" doxytag="oscl_mem_audit_internals.h::FENCE_PATTERN"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define FENCE_PATTERN&nbsp;&nbsp;&nbsp;0xAA
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a80" doxytag="oscl_mem_audit_internals.h::MEM_ALIGN_SIZE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MEM_ALIGN_SIZE&nbsp;&nbsp;&nbsp;8
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a79" doxytag="oscl_mem_audit_internals.h::MIN_FENCE_SIZE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MIN_FENCE_SIZE&nbsp;&nbsp;&nbsp;4
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a63" doxytag="oscl_mem_audit.h::MM_ALLOC_MAX_QUERY_FILENAME_LEN"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_ALLOC_MAX_QUERY_FILENAME_LEN&nbsp;&nbsp;&nbsp;128
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a64" doxytag="oscl_mem_audit.h::MM_ALLOC_MAX_QUERY_TAG_LEN"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_ALLOC_MAX_QUERY_TAG_LEN&nbsp;&nbsp;&nbsp;64
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a70" doxytag="oscl_mem_audit.h::MM_AUDIT_ALLOC_NODE_ENABLE_FLAG"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_ALLOC_NODE_ENABLE_FLAG&nbsp;&nbsp;&nbsp;0x10
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a73" doxytag="oscl_mem_audit_internals.h::MM_AUDIT_ALLOC_NODE_SUPPORT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_ALLOC_NODE_SUPPORT&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a77" doxytag="oscl_mem_audit_internals.h::MM_AUDIT_FAILURE_SIMULATION_SUPPORT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_FAILURE_SIMULATION_SUPPORT&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a74" doxytag="oscl_mem_audit_internals.h::MM_AUDIT_FENCE_SUPPORT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_FENCE_SUPPORT&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a76" doxytag="oscl_mem_audit_internals.h::MM_AUDIT_FILL_SUPPORT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_FILL_SUPPORT&nbsp;&nbsp;&nbsp;0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a75" doxytag="oscl_mem_audit_internals.h::MM_AUDIT_INCLUDE_ALL_HEAP_VALIDATION"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_INCLUDE_ALL_HEAP_VALIDATION&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a67" doxytag="oscl_mem_audit.h::MM_AUDIT_POSTFILL_FLAG"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_POSTFILL_FLAG&nbsp;&nbsp;&nbsp;0x2
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a66" doxytag="oscl_mem_audit.h::MM_AUDIT_PREFILL_FLAG"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_PREFILL_FLAG&nbsp;&nbsp;&nbsp;0x1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a71" doxytag="oscl_mem_audit.h::MM_AUDIT_SUPPRESS_FILENAME_FLAG"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_SUPPRESS_FILENAME_FLAG&nbsp;&nbsp;&nbsp;0x20
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a68" doxytag="oscl_mem_audit.h::MM_AUDIT_VALIDATE_ALL_HEAP_FLAG"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_VALIDATE_ALL_HEAP_FLAG&nbsp;&nbsp;&nbsp;0x4
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a65" doxytag="oscl_mem_audit.h::MM_AUDIT_VALIDATE_BLOCK"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_VALIDATE_BLOCK&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a69" doxytag="oscl_mem_audit.h::MM_AUDIT_VALIDATE_ON_FREE_FLAG"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define MM_AUDIT_VALIDATE_ON_FREE_FLAG&nbsp;&nbsp;&nbsp;0x8
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a38" doxytag="oscl_mem.h::OSCL_ALLOC_DELETE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_ALLOC_DELETE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ptr,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_allocator,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>{\
  ptr-&gt;~T();\
  T_allocator.deallocate(ptr);\
  }</pre></div>Deletes the object of type T using the given allocator<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>T_allocator</em>&nbsp;</td><td>
allocator for objects of type T </td></tr>
<tr><td valign=top><em>T</em>&nbsp;</td><td>
type of object to delete </td></tr>
<tr><td valign=top><em>ptr</em>&nbsp;</td><td>
pointer to previously created object</td></tr>
</table>
</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>none</em>&nbsp;</td><td>
, unless thrown by the given allocator </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a36" doxytag="oscl_mem.h::OSCL_ALLOC_NEW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_ALLOC_NEW</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_allocator,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>params&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;new(T_allocator.allocate(1)) T params
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an object of type T using the given allocator to acquire the memory needed.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>T_allocator</em>&nbsp;</td><td>
allocator for objects of type T, must be an <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;T, Allocator&gt;, where Allocator is an <a class="el" href="classOscl__DefAlloc.html">Oscl_DefAlloc</a> </td></tr>
<tr><td valign=top><em>T</em>&nbsp;</td><td>
type of object to create </td></tr>
<tr><td valign=top><em>params</em>&nbsp;</td><td>
object initialization parameters</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
pointer to created object</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>none</em>&nbsp;</td><td>
, unless thrown by the given allocator </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a60" doxytag="oscl_mem.h::OSCL_ARRAY_DELETE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_ARRAY_DELETE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ptr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;delete [] ptr
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Oscl array delete operator..<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>ptr</em>&nbsp;</td><td>
pointer to memory block previously allocated with OSCL_ARRAY_NEW</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
void </dl>    </td>
  </tr>
</table>
<a name="a59" doxytag="oscl_mem.h::OSCL_ARRAY_NEW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_ARRAY_NEW</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>count&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;new T[count]
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Oscl array "new" operator. This uses the global memory audit object.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>T</em>&nbsp;</td><td>
data type for 'new' operation </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
number of elements to create</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
pointer to the newly created object array of type T</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>may</em>&nbsp;</td><td>
 leave with code = bad alloc </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a58" doxytag="oscl_mem.h::OSCL_AUDIT_ARRAY_NEW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_AUDIT_ARRAY_NEW</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">auditCB,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>count&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;new(_oscl_audit_new(sizeof(T)*(count),auditCB)) T
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Oscl array "new" operator. This uses the input memory audit object.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>auditCB</em>&nbsp;</td><td>
input memory management audit object </td></tr>
<tr><td valign=top><em>T</em>&nbsp;</td><td>
data type for 'new' operation </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
number of elements to create</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
pointer to the newly created object array of type T</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>may</em>&nbsp;</td><td>
 leave with code = bad alloc </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a45" doxytag="oscl_mem.h::OSCL_AUDIT_CALLOC"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_AUDIT_CALLOC</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">auditCB,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>num,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_oscl_audit_calloc(num,size, auditCB)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocates a memory block using the specified audit object. The block is initialized to zero.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>auditCB</em>&nbsp;</td><td>
input memory management audit object </td></tr>
<tr><td valign=top><em>num</em>&nbsp;</td><td>
number of elements </td></tr>
<tr><td valign=top><em>size</em>&nbsp;</td><td>
number of bytes to allocate for each element</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
a void pointer to the allocated space, or NULL if there is insufficient memory available.</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>none</em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a42" doxytag="oscl_mem.h::OSCL_AUDIT_MALLOC"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_AUDIT_MALLOC</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">auditCB,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>count&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_oscl_audit_malloc(count, auditCB)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocates a memory block using the given audit object.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>auditCB</em>&nbsp;</td><td>
input memory management audit object </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
number of bytes to allocate</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
a void pointer to the allocated space, or NULL if there is insufficient memory available.</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>none</em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a55" doxytag="oscl_mem.h::OSCL_AUDIT_NEW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_AUDIT_NEW</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">auditCB,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>params&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;new(_oscl_audit_new(sizeof(T),auditCB)) T params
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Oscl "new" operator. This uses the specified memory audit object.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>auditCB</em>&nbsp;</td><td>
input memory management audit object </td></tr>
<tr><td valign=top><em>T</em>&nbsp;</td><td>
data type for 'new' operation </td></tr>
<tr><td valign=top><em>params</em>&nbsp;</td><td>
object initialization parameters</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
pointer to the newly created object of type T</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>may</em>&nbsp;</td><td>
 leave with code = bad alloc </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a48" doxytag="oscl_mem.h::OSCL_AUDIT_REALLOC"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_AUDIT_REALLOC</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">auditCB,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>ptr,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>new_size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_oscl_audit_realloc(ptr,new_size, auditCB)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Re-Allocates a memory block using the specified audit object.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>auditCB</em>&nbsp;</td><td>
input memory management audit object </td></tr>
<tr><td valign=top><em>ptr</em>&nbsp;</td><td>
original memory block </td></tr>
<tr><td valign=top><em>new_size</em>&nbsp;</td><td>
New size of the block</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
a void pointer to the allocated space, or NULL if there is insufficient memory available.</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>none</em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a44" doxytag="oscl_mem.h::oscl_calloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define oscl_calloc</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">a,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>b&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;OSCL_CALLOC(a,b)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a43" doxytag="oscl_mem.h::OSCL_CALLOC"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_CALLOC</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">num,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_oscl_default_audit_calloc(num,size)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocates a memory block using the memory management's global audit object. The block is initialized to zero.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>num</em>&nbsp;</td><td>
number of elements </td></tr>
<tr><td valign=top><em>size</em>&nbsp;</td><td>
number of bytes to allocate for each element</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
a void pointer to the allocated space, or NULL if there is insufficient memory available.</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>none</em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a35" doxytag="oscl_mem.h::OSCL_CLEANUP_BASE_CLASS"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_CLEANUP_BASE_CLASS</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_OSCL_CLEANUP_BASE_CLASS(T)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cleans up the base class of a partially-constructed derived class. This macro will call the destructor if necessary, based on the error-handling implementation.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>T:</em>&nbsp;</td><td>
name of the base class. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a51" doxytag="oscl_mem.h::OSCL_DEFAULT_FREE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_DEFAULT_FREE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;OSCL_FREE(x)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Another back-compatibility definition.     </td>
  </tr>
</table>
<a name="a41" doxytag="oscl_mem.h::OSCL_DEFAULT_MALLOC"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_DEFAULT_MALLOC</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;OSCL_MALLOC(x)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Another back-compatibility definition.     </td>
  </tr>
</table>
<a name="a57" doxytag="oscl_mem.h::OSCL_DELETE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_DELETE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ptr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Value:</b><div class="fragment"><pre>{\
    <span class="keywordflow">if</span>(ptr){<span class="keyword">delete</span>(ptr);}\
}</pre></div>Oscl "delete" operator.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>ptr</em>&nbsp;</td><td>
pointer to memory block previously allocated with OSCL_NEW</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
void </dl>    </td>
  </tr>
</table>
<a name="a84" doxytag="oscl_mem_auto_ptr.h::OSCL_DISABLE_WARNING_RETURN_TYPE_NOT_UDT"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_DISABLE_WARNING_RETURN_TYPE_NOT_UDT
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a33" doxytag="oscl_mem.h::OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_DISABLE_WARNING_TRUNCATE_DEBUG_MESSAGE
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Previously this was in oscl_mem_imp.h     </td>
  </tr>
</table>
<a name="a50" doxytag="oscl_mem.h::oscl_free"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define oscl_free</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">x&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;OSCL_FREE(x)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a49" doxytag="oscl_mem.h::OSCL_FREE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_FREE</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ptr&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_oscl_audit_free(ptr)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Deallocates or frees a memory block.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>ptr</em>&nbsp;</td><td>
pointer to previously allocated memory block using the given audit object </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a34" doxytag="oscl_mem.h::OSCL_HAS_GLOBAL_NEW_DELETE"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_HAS_GLOBAL_NEW_DELETE&nbsp;&nbsp;&nbsp;1
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a40" doxytag="oscl_mem.h::oscl_malloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define oscl_malloc</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">a&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;OSCL_MALLOC(a)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a39" doxytag="oscl_mem.h::OSCL_MALLOC"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_MALLOC</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">count&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_oscl_default_audit_malloc(count)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Allocates a memory block using the memory management's global audit object.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
number of bytes to allocate</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
a void pointer to the allocated space, or NULL if there is insufficient memory available.</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>none</em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a52" doxytag="oscl_mem.h::OSCL_NEW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_NEW</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>params&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;new T params
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Oscl "new" operator. This uses the global memory audit object.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>T</em>&nbsp;</td><td>
data type for 'new' operation </td></tr>
<tr><td valign=top><em>params</em>&nbsp;</td><td>
object initialization parameters</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
pointer to the newly created object of type T</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>may</em>&nbsp;</td><td>
 leave with code = bad alloc </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a53" doxytag="oscl_mem.h::OSCL_PLACEMENT_NEW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_PLACEMENT_NEW</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ptr,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>constructor&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;new(ptr) constructor
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a47" doxytag="oscl_mem.h::oscl_realloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define oscl_realloc</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">a,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>b&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;OSCL_REALLOC(a,b)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a46" doxytag="oscl_mem.h::OSCL_REALLOC"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_REALLOC</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ptr,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>new_size&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_oscl_default_audit_realloc(ptr,new_size)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Re-Allocates a memory block using the memory management's global audit object.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>ptr</em>&nbsp;</td><td>
original memory block </td></tr>
<tr><td valign=top><em>new_size</em>&nbsp;</td><td>
New size of the block</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
a void pointer to the allocated space, or NULL if there is insufficient memory available.</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>none</em>&nbsp;</td><td>
 </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a37" doxytag="oscl_mem.h::OSCL_TRAP_ALLOC_NEW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_TRAP_ALLOC_NEW</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_ptr,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T_allocator,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>params&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(T_allocator.allocate(1),T_allocator.deallocate,T_ptr,T,params)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Creates an object of type T using the given allocator to acquire the memory needed. This macro is similar to OSCL_ALLOC_NEW except that it handles constructors that leave. If the constructor leaves, the destructor will be called, and allocated memory will be freed before allowing the leave to propagate to the next level.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>T_ptr</em>&nbsp;</td><td>
variable to hold return value-- pointer to new object of type T. </td></tr>
<tr><td valign=top><em>T_allocator</em>&nbsp;</td><td>
allocator for objects of type T, must be an <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;T, Allocator&gt;, where Allocator is an <a class="el" href="classOscl__DefAlloc.html">Oscl_DefAlloc</a> </td></tr>
<tr><td valign=top><em>T</em>&nbsp;</td><td>
type of object to create </td></tr>
<tr><td valign=top><em>params</em>&nbsp;</td><td>
object initialization parameters</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
pointer to created object</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>none</em>&nbsp;</td><td>
, unless thrown by the given allocator </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a56" doxytag="oscl_mem.h::OSCL_TRAP_AUDIT_NEW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_TRAP_AUDIT_NEW</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_ptr,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>auditCB,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>params&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(_oscl_audit_new(sizeof(T),auditCB),_oscl_audit_free,T_ptr,T,params)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Oscl "new" operator. This uses the specified memory audit object. This macro is similar to OSCL_AUDIT_NEW except that it will handle constructors that leave. If the constructor leaves, the destructor will be called, and allocated memory will be freed before allowing the leave to propagate to the next level.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>T_ptr</em>&nbsp;</td><td>
variable to hold return value-- pointer to new object of type T. </td></tr>
<tr><td valign=top><em>auditCB</em>&nbsp;</td><td>
input memory management audit object </td></tr>
<tr><td valign=top><em>T</em>&nbsp;</td><td>
data type for 'new' operation </td></tr>
<tr><td valign=top><em>params</em>&nbsp;</td><td>
object initialization parameters</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
pointer to the newly created object of type T</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>may</em>&nbsp;</td><td>
 leave with code = bad alloc </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a54" doxytag="oscl_mem.h::OSCL_TRAP_NEW"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> #define OSCL_TRAP_NEW</td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">T_ptr,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>T,         <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>params&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap>&nbsp;&nbsp;&nbsp;_OSCL_TRAP_NEW(_oscl_default_audit_new(sizeof(T)),_oscl_audit_free,T_ptr,T,params)
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Oscl "new" operator. This uses the global memory audit object. This operator is similar to OSCL_NEW except that it will handle constructors that leave. If the constructor leaves, the destructor will be called, and allocated memory will be freed before allowing the leave to propagate to the next level.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>T_ptr</em>&nbsp;</td><td>
variable to hold return value-- pointer to new object of type T. </td></tr>
<tr><td valign=top><em>T</em>&nbsp;</td><td>
data type for 'new' operation </td></tr>
<tr><td valign=top><em>params</em>&nbsp;</td><td>
object initialization parameters</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
pointer to the newly created object of type T</dl><dl compact><dt><b>Exceptions: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>may</em>&nbsp;</td><td>
 leave with code = bad alloc </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><h2>Typedef Documentation</h2>
<a name="a2" doxytag="oscl_mem_audit.h::MM_AllocNodeAutoPtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt;<a class="el" href="structMM__AllocNode.html">MM_AllocNode</a>, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;<a class="el" href="structMM__AllocNode.html">MM_AllocNode</a>, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a>&gt; &gt; MM_AllocNodeAutoPtr
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a3" doxytag="oscl_mem_audit.h::MM_StatsNodeTagTreeType"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt;<a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;<a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a>&gt; &gt; MM_StatsNodeTagTreeType
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a0" doxytag="oscl_mem_audit.h::MMAuditCharAutoPtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt;char, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;char, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a>&gt; &gt; MMAuditCharAutoPtr
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a1" doxytag="oscl_mem_audit.h::MMAuditUint8AutoPtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt;uint8, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;uint8, <a class="el" href="class__OsclBasicAllocator.html">_OsclBasicAllocator</a>&gt; &gt; MMAuditUint8AutoPtr
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a4" doxytag="oscl_mem_audit.h::OsclMemStatsNodeAutoPtr"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classOSCLMemAutoPtr.html">OSCLMemAutoPtr</a>&lt;<a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;<a class="el" href="classOsclMemStatsNode.html">OsclMemStatsNode</a>, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a>&gt; &gt; OsclMemStatsNodeAutoPtr
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a6" doxytag="oscl_mem_audit.h::OsclTagTreeType"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classOscl__TagTree.html">Oscl_TagTree</a>&lt;<a class="el" href="group__osclmemory.html#a3">MM_StatsNodeTagTreeType</a>, <a class="el" href="group__osclmemory.html#a5">TagTree_Allocator</a>&gt; OsclTagTreeType
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a5" doxytag="oscl_mem_audit.h::TagTree_Allocator"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> typedef <a class="el" href="classOscl__TAlloc.html">Oscl_TAlloc</a>&lt;<a class="el" href="group__osclmemory.html#a3">MM_StatsNodeTagTreeType</a>, <a class="el" href="classOsclMemBasicAllocator.html">OsclMemBasicAllocator</a>&gt; TagTree_Allocator
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a19" doxytag="oscl_mem.h::_oscl_audit_calloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void* _oscl_audit_calloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>f</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>l</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a26" doxytag="oscl_mem.h::_oscl_audit_free"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void _oscl_audit_free </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a18" doxytag="oscl_mem.h::_oscl_audit_malloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void* _oscl_audit_malloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>f</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>l</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
******************************************************* Macros for malloc/free with memory management.     </td>
  </tr>
</table>
<a name="a21" doxytag="oscl_mem.h::_oscl_audit_new"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void* _oscl_audit_new </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>f</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>l</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a20" doxytag="oscl_mem.h::_oscl_audit_realloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void* _oscl_audit_realloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>f</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>l</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a8" doxytag="oscl_mem_basic_functions.h::_oscl_calloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_COND_IMPORT_REF void* _oscl_calloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>nelems</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a23" doxytag="oscl_mem.h::_oscl_default_audit_calloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void* _oscl_default_audit_calloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>f</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>l</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a22" doxytag="oscl_mem.h::_oscl_default_audit_malloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void* _oscl_default_audit_malloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>f</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>l</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a25" doxytag="oscl_mem.h::_oscl_default_audit_new"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void* _oscl_default_audit_new </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>f</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>l</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a24" doxytag="oscl_mem.h::_oscl_default_audit_realloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void* _oscl_default_audit_realloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp;, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>f</em> = NULL, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>l</em> = 0</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a10" doxytag="oscl_mem_basic_functions.h::_oscl_free"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_COND_IMPORT_REF void _oscl_free </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>src</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a7" doxytag="oscl_mem_basic_functions.h::_oscl_malloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_COND_IMPORT_REF void* _oscl_malloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>count</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a9" doxytag="oscl_mem_basic_functions.h::_oscl_realloc"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_COND_IMPORT_REF void* _oscl_realloc </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a29" doxytag="osclconfig_global_new_delete.h::operator delete"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void operator delete </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a32" doxytag="oscl_mem.h::operator delete[]"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void operator delete[] </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aPtr</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a28" doxytag="osclconfig_global_new_delete.h::operator new"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* operator new </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a27" doxytag="oscl_mem.h::operator new"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* operator new </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aSize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aFile</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLine</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a31" doxytag="oscl_mem.h::operator new[]"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* operator new[] </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aSize</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a30" doxytag="oscl_mem.h::operator new[]"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void* operator new[] </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aSize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aFile</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLine</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<a name="a16" doxytag="oscl_mem.h::oscl_mem_aligned_size"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_COND_IMPORT_REF <a class="el" href="group__osclbase.html#a27">uint</a> oscl_mem_aligned_size </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__osclbase.html#a27">uint</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>size</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get memory-aligned size of an object.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>size</em>&nbsp;</td><td>
size of object</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
memory-aligned size </dl>    </td>
  </tr>
</table>
<a name="a15" doxytag="oscl_mem_basic_functions.h::oscl_memcmp"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_COND_IMPORT_REF int oscl_memcmp </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buf1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>buf2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Compare characters in two buffers<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>buf1</em>&nbsp;</td><td>
first buffer </td></tr>
<tr><td valign=top><em>buf2</em>&nbsp;</td><td>
second buffer </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
number of bytes to compare</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
&lt;0 buf1 less than buf2 0 buf1 equal to buf2 &gt;0 buf1 greater than buf2 </dl>    </td>
  </tr>
</table>
<a name="a11" doxytag="oscl_mem_basic_functions.h::oscl_memcpy"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_COND_IMPORT_REF void* oscl_memcpy </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copies characters between buffers The oscl_memcpy function copies count bytes of src to dest. If the source and destination overlap, this function does not ensure that the original source bytes in the overlapping region are copied before being overwritten. Use oscl_memmove to handle overlapping regions<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
new buffer </td></tr>
<tr><td valign=top><em>src</em>&nbsp;</td><td>
buffer to copy </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
number of bytes to copy</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
the value of dest </dl>    </td>
  </tr>
</table>
<a name="a12" doxytag="oscl_mem_basic_functions.h::oscl_memmove"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_COND_IMPORT_REF void* oscl_memmove </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Moves chars from one buffer to another The memmove function copies count bytes of characters from src to dest. If some regions of the source area and the destination overlap, memmove ensures that the original source bytes in the overlapping region are copied before being overwritten.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
new buffer </td></tr>
<tr><td valign=top><em>src</em>&nbsp;</td><td>
buffer to copy </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
number of bytes to copy</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
the value of dest </dl>    </td>
  </tr>
</table>
<a name="a13" doxytag="oscl_mem_basic_functions.h::oscl_memmove32"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_COND_IMPORT_REF void* oscl_memmove32 </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>src</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same functionality as oscl_memmove, yet optimized for memory alligned on 32-bit boundary<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
new buffer </td></tr>
<tr><td valign=top><em>src</em>&nbsp;</td><td>
buffer to copy </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
number of bytes to copy</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
the value of dest </dl>    </td>
  </tr>
</table>
<a name="a14" doxytag="oscl_mem_basic_functions.h::oscl_memset"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_COND_IMPORT_REF void* oscl_memset </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">void *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dest</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint8&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>val</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>count</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Sets the bytes of a buffer to a specified character<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>dest</em>&nbsp;</td><td>
buffer to modify </td></tr>
<tr><td valign=top><em>val</em>&nbsp;</td><td>
character to set </td></tr>
<tr><td valign=top><em>count</em>&nbsp;</td><td>
number of bytes to set</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
the value of dest </dl>    </td>
  </tr>
</table>
<a name="a17" doxytag="oscl_mem.h::OsclMemInit"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclMemInit </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>auditCB</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize an <a class="el" href="classOsclAuditCB.html">OsclAuditCB</a> object. Sets the stats node pointer to null, and sets the audit pointer to the global audit object.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>auditCB</em>&nbsp;</td><td>
memory management audit object </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a name="a85" doxytag="MM_AllocBlockHdr::ALLOC_NODE_FLAG"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> const uint32 MM_AllocBlockHdr::ALLOC_NODE_FLAG = 0x80000000<code> [static, inherited]</code>
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
    </td>
  </tr>
</table>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: OPENCORE_20090310 </small>
</small></address>
</body>
</html>
