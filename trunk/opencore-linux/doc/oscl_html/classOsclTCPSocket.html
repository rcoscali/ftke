<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>OsclTCPSocket class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="modules.html">Modules</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Data Structures</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Data Fields</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>OsclTCPSocket Class Reference<br>
<small>
[<a class="el" href="group__osclio.html">OSCL IO</a>]</small>
</h1><code>#include &lt;<a class="el" href="oscl__socket_8h-source.html">oscl_socket.h</a>&gt;</code>
<p>
<p>Inheritance diagram for OsclTCPSocket:
<p><center><img src="classOsclTCPSocket.png" usemap="#OsclTCPSocket_map" border="0" alt=""></center>
<map name="OsclTCPSocket_map">
<area href="classHeapBase.html" alt="HeapBase" shape="rect" coords="0,56,103,80">
<area href="class__OsclHeapBase.html" alt="_OsclHeapBase" shape="rect" coords="0,0,103,24">
</map>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a0">~OsclTCPSocket</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF int32&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a1">Close</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF int32&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a2">Bind</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a>&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a3">BindAsync</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress, int32 aTimeoutMsec=(-1))</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a4">CancelBind</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF int32&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a5">Listen</a> (int32 aQueueSize)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a>&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a6">ListenAsync</a> (int32 aQueueSize, int32 aTimeoutMsec=(-1))</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a7">CancelListen</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF OsclTCPSocket *&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a8">GetAcceptedSocketL</a> (uint32 aId)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF uint8 *&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a9">GetRecvData</a> (int32 *aLength)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF uint8 *&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a10">GetSendData</a> (int32 *aLength)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a>&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a11">Connect</a> (<a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;aAddress, int32 aTimeoutMsec=-1)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a12">CancelConnect</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a>&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a13">Shutdown</a> (<a class="el" href="oscl__socket__types_8h.html#a21">TPVSocketShutdown</a> aHow, int32 aTimeoutMsec=-1)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a14">CancelShutdown</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a>&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a15">Accept</a> (int32 aTimeout=-1)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a16">CancelAccept</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a>&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a17">Send</a> (const uint8 *aPtr, uint32 aLen, int32 aTimeoutMsec=-1)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a18">CancelSend</a> ()</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a>&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a19">Recv</a> (uint8 *aPtr, uint32 aMaxLen, int32 aTimeoutMsec=-1)</td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF void&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#a20">CancelRecv</a> ()</td></tr>
<tr><td colspan=2><br><h2>Static Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>OSCL_IMPORT_REF OsclTCPSocket *&nbsp;</td><td valign=bottom><a class="el" href="classOsclTCPSocket.html#d0">NewL</a> (<a class="el" href="classOscl__DefAlloc.html">Oscl_DefAlloc</a> &amp;alloc, <a class="el" href="classOsclSocketServ.html">OsclSocketServ</a> &amp;aServ, <a class="el" href="classOsclSocketObserver.html">OsclSocketObserver</a> *aObserver, uint32 aId)</td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The TCP Socket class 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="OsclTCPSocket::~OsclTCPSocket"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF OsclTCPSocket::~OsclTCPSocket </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Destructor. The object must be deleted using the same allocator used in the NewL call.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a15" doxytag="OsclTCPSocket::Accept"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a> OsclTCPSocket::Accept </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aTimeout</em> = -1          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Accept incoming connections. This is an asynchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aTimeoutMsec:</em>&nbsp;</td><td>
Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="OsclTCPSocket::Bind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF int32 OsclTCPSocket::Bind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aAddress</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bind a TCP socket to an address. This is a synchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aAddress:</em>&nbsp;</td><td>
Bind address. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns OsclErrNone for success, or a platform-specific error code. </dl>    </td>
  </tr>
</table>
<a name="a3" doxytag="OsclTCPSocket::BindAsync"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a> OsclTCPSocket::BindAsync </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aAddress</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimeoutMsec</em> = (-1)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Bind a TCP socket to an address. This is an asynchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aAddress:</em>&nbsp;</td><td>
Bind address. </td></tr>
<tr><td valign=top><em>aTimeoutMsec:</em>&nbsp;</td><td>
Optional timeout. Use a negative value for infinite wait. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dl>    </td>
  </tr>
</table>
<a name="a16" doxytag="OsclTCPSocket::CancelAccept"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclTCPSocket::CancelAccept </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel Accept
<p>
This method will cancel any pending Accept operation on the current socket, causing the Accept to complete with error EPVSocketCancel. If there is no pending Accept operation, this method will have no effect.     </td>
  </tr>
</table>
<a name="a4" doxytag="OsclTCPSocket::CancelBind"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclTCPSocket::CancelBind </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel Bind
<p>
This method will cancel any pending BindAsync operation on the current socket, causing the BindAsync to complete with error EPVSocketCancel. If there is no pending BindAsync operation, this method will have no effect.     </td>
  </tr>
</table>
<a name="a12" doxytag="OsclTCPSocket::CancelConnect"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclTCPSocket::CancelConnect </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel Connect
<p>
This method will cancel any pending Connect operation on the current socket, causing the Connect to complete with error EPVSocketCancel. If there is no pending Connect operation, this method will have no effect.     </td>
  </tr>
</table>
<a name="a7" doxytag="OsclTCPSocket::CancelListen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclTCPSocket::CancelListen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel Async Listen
<p>
This method will cancel any pending ListenAsync operation on the current socket, causing the Listen to complete with error EPVSocketCancel. If there is no pending Listen operation, this method will have no effect.     </td>
  </tr>
</table>
<a name="a20" doxytag="OsclTCPSocket::CancelRecv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclTCPSocket::CancelRecv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel Recv
<p>
This method will cancel any pending Recv operation on the current socket, causing the Recv to complete with error EPVSocketCancel. If there is no pending Recv operation, this method will have no effect.     </td>
  </tr>
</table>
<a name="a18" doxytag="OsclTCPSocket::CancelSend"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclTCPSocket::CancelSend </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel Send
<p>
This method will cancel any pending Send operation on the current socket, causing the Send to complete with error EPVSocketCancel. If there is no pending Send operation, this method will have no effect.     </td>
  </tr>
</table>
<a name="a14" doxytag="OsclTCPSocket::CancelShutdown"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF void OsclTCPSocket::CancelShutdown </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Cancel Shutdown
<p>
This method will cancel any pending Shutdown operation on the current socket, causing the Shutdown to complete with error EPVSocketCancel. If there is no pending Shutdown operation, this method will have no effect.     </td>
  </tr>
</table>
<a name="a1" doxytag="OsclTCPSocket::Close"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF int32 OsclTCPSocket::Close </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Close a TCP socket. This is a synchronous method.
<p>
Once it is closed a socket cannot be re-opened. Sockets are automatically closed when they are deleted. This method may be used to see any error code returned from the platform's socket close call. <dl compact><dt><b>Returns: </b></dt><dd>
Returns OsclErrNone for success, or a platform-specific error code. </dl>    </td>
  </tr>
</table>
<a name="a11" doxytag="OsclTCPSocket::Connect"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a> OsclTCPSocket::Connect </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classOsclNetworkAddress.html">OsclNetworkAddress</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aAddress</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimeoutMsec</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Connect to an address. This is an asynchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aAddress:</em>&nbsp;</td><td>
a network address. </td></tr>
<tr><td valign=top><em>aTimeoutMsec:</em>&nbsp;</td><td>
Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dl>    </td>
  </tr>
</table>
<a name="a8" doxytag="OsclTCPSocket::GetAcceptedSocketL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF OsclTCPSocket* OsclTCPSocket::GetAcceptedSocketL </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aId</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the accept socket after a successful Accept operation. This is a synchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aId:</em>&nbsp;</td><td>
Socket ID. The caller must assign an ID to each socket. The ID is used to identify the socket in observer callbacks. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns pointer to socket, or NULL if error. Note: The caller is reponsible for deleting any accepted socket that it retrieves. </dl>    </td>
  </tr>
</table>
<a name="a9" doxytag="OsclTCPSocket::GetRecvData"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF uint8* OsclTCPSocket::GetRecvData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aLength</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the received data after a successful Recv operation. This is a synchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aLength:</em>&nbsp;</td><td>
(output) number of bytes of data received. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns pointer to received data, or NULL if none. </dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="OsclTCPSocket::GetSendData"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF uint8* OsclTCPSocket::GetSendData </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32 *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aLength</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Retrieve the sent data after a successful Send operation. This is a synchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aLength:</em>&nbsp;</td><td>
(output) number of bytes of data sent. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns pointer to sent data, or NULL if none. </dl>    </td>
  </tr>
</table>
<a name="a5" doxytag="OsclTCPSocket::Listen"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF int32 OsclTCPSocket::Listen </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>aQueueSize</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Listen. This is a synchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aQueueSize:</em>&nbsp;</td><td>
Queue size. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns OsclErrNone for success, or a platform-specific error code. </dl>    </td>
  </tr>
</table>
<a name="a6" doxytag="OsclTCPSocket::ListenAsync"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a> OsclTCPSocket::ListenAsync </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aQueueSize</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimeoutMsec</em> = (-1)</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
ListenAsync This is an asynchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aQueueSize:</em>&nbsp;</td><td>
Queue size. </td></tr>
<tr><td valign=top><em>aTimeoutMsec:</em>&nbsp;</td><td>
Optional timeout. Use a negative value for infinite wait. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dl>    </td>
  </tr>
</table>
<a name="d0" doxytag="OsclTCPSocket::NewL"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF OsclTCPSocket* OsclTCPSocket::NewL </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classOscl__DefAlloc.html">Oscl_DefAlloc</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>alloc</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOsclSocketServ.html">OsclSocketServ</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aServ</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classOsclSocketObserver.html">OsclSocketObserver</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aObserver</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aId</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [static]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a TCP Socket. May leave if failure.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>alloc:</em>&nbsp;</td><td>
Memory allocator. </td></tr>
<tr><td valign=top><em>aServ:</em>&nbsp;</td><td>
Socket server. Must be connected. </td></tr>
<tr><td valign=top><em>aObserver:</em>&nbsp;</td><td>
Socket observer. </td></tr>
<tr><td valign=top><em>aId:</em>&nbsp;</td><td>
Socket ID. The caller must assign an ID to each socket. The ID is used to identify the socket in observer callbacks. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Returns pointer to socket. </dl>    </td>
  </tr>
</table>
<a name="a19" doxytag="OsclTCPSocket::Recv"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a> OsclTCPSocket::Recv </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">uint8 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aPtr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aMaxLen</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimeoutMsec</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Receive Data. This is an asynchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aPtr:</em>&nbsp;</td><td>
Buffer for received data. </td></tr>
<tr><td valign=top><em>aMaxLen:</em>&nbsp;</td><td>
Length of buffer. </td></tr>
<tr><td valign=top><em>aTimeoutMsec:</em>&nbsp;</td><td>
Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dl>    </td>
  </tr>
</table>
<a name="a17" doxytag="OsclTCPSocket::Send"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a> OsclTCPSocket::Send </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const uint8 *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aPtr</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>uint32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aLen</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimeoutMsec</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Send Data. This is an asynchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aPtr:</em>&nbsp;</td><td>
Data to send. </td></tr>
<tr><td valign=top><em>aLen:</em>&nbsp;</td><td>
Length of data to send. </td></tr>
<tr><td valign=top><em>aTimeoutMsec:</em>&nbsp;</td><td>
Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dl>    </td>
  </tr>
</table>
<a name="a13" doxytag="OsclTCPSocket::Shutdown"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> OSCL_IMPORT_REF <a class="el" href="oscl__socket__types_8h.html#a20">TPVSocketEvent</a> OsclTCPSocket::Shutdown </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="oscl__socket__types_8h.html#a21">TPVSocketShutdown</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aHow</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>int32&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>aTimeoutMsec</em> = -1</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Shutdown a socket. This is an asynchronous method.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>aHow:</em>&nbsp;</td><td>
type of shutdown </td></tr>
<tr><td valign=top><em>aTimeoutMsec:</em>&nbsp;</td><td>
Timeout in milliseconds, or (-1) for infinite wait. </td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
Will return EPVSocketPending if successful. When the operation is complete, a callback to the observer will occur with the completion status. If the operation cannot be initiated, the call will return EPVSocketFailure and there will be no callback. </dl>    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="oscl__socket_8h-source.html">oscl_socket.h</a></ul>
<hr size="1"><img src="pvlogo_small.jpg"><address style="align: right;"><small>OSCL API</small>
<address style="align: left;"><small>Posting Version: OPENCORE_20090310 </small>
</small></address>
</body>
</html>
