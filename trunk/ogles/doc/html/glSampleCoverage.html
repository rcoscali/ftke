<html>
  <head>
    <title>glSampleCoverage</title>
    <link rel="stylesheet" href="man.css" type="text/css"/>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
    <meta name="keywords" content="OpenGL ES, glSampleCoverage, man"/>
    <meta name="description" content="OpenGL ES man page of glSampleCoverage"/>
  </head>
  <body><h2>Name</h2><p> <code><strong>glSampleCoverage</strong></code> , <code><strong>glSampleCoveragex</strong></code>  - specify mask to modify multisampled pixel fragments</p><h2>C Specification</h2> <pre>void <strong>glSampleCoverage</strong>(GLclampf <var>value</var>, GLboolean <var>invert</var>)
void <strong>glSampleCoveragex</strong>(GLclampx <var>value</var>, GLboolean <var>invert</var>)</pre><h2>Parameters</h2> <dl><dt><code><var>value</var></code></dt> <dd><p>Specifies the coverage of the modification mask. The value is clamped to the range [0, 1], where 0 represents no coverage and 1 full coverage. The initial value is 1.</p></dd> <dt><code><var>invert</var></code></dt> <dd><p>Specifies whether the modification mask implied by <code><var>value</var></code> is inverted or not. The initial value is <code>GL_FALSE</code>.</p></dd></dl><h2>Description</h2> <p><code><strong>glSampleCoverage</strong></code> defines a mask to modify the coverage of multisampled pixel fragments. This capability is used for antialiased screen-door transparency and smooth transitions between two renderings of an object (often for level-of-detail management in simulation systems).</p> <p>When multisampling is enabled (see <a href="glEnable.html"><code><strong>glEnable</strong></code></a> with argument <code>GL_MULTISAMPLE</code>) a ``fragment mask'' is computed for each fragment generated by a primitive. This mask reflects the amount of the pixel covered by the fragment, and determines the frame buffer samples that may be affected by the fragment.</p> <p>If conversion of alpha values to masks is enabled (<a href="glEnable.html"><code><strong>glEnable</strong></code></a> with argument <code>GL_SAMPLE_ALPHA_TO_MASK</code>), the fragment alpha value is used to generate a temporary modification mask which is then ANDed with the fragment mask. One way to interpret this is as a form of dithering: a multivalued alpha (coverage or opacity) for the whole fragment is converted to simple binary values of coverage at many locations (the samples).</p> <p>After conversion of alpha values to masks, if replacement of alpha values is enabled (<a href="glEnable.html"><code><strong>glEnable</strong></code></a> with argument <code>GL_SAMPLE_ALPHA_TO_ONE</code>), the fragment's alpha is set to the maximum allowable value.</p> <p>Finally, if fragment mask modification is enabled (<a href="glEnable.html"><code><strong>glEnable</strong></code></a> with argument <code>GL_SAMPLE_MASK</code>), <code><strong>glSampleCoverage</strong></code> defines an additional modification mask. value is used to generate a modification mask in much the same way alpha was used above. If invert is <code>GL_TRUE</code>, then the modification mask specified by value will be inverted. The final modification mask will then be ANDed with the fragment mask resulting from the previous steps. This can be viewed as an ``override'' control that selectively fades the effects of multisampled fragments.</p> <p>Note that <code><strong>glSampleCoverage</strong></code>(value, <code>GL_TRUE</code>) is not necessarily equivalent to <code><strong>glSampleCoverage</strong></code>(1.0 - value, <code>GL_FALSE</code>); due to round-off and other issues, complementing the coverage will not necessarily yield an inverted modification mask.</p><h2>Copyright</h2> <p>Copyright Â© 2003-2004 Silicon Graphics, Inc.</p> <p>This document is licensed under the SGI Free Software B License. For details, see <a href="http://oss.sgi.com/projects/FreeB/">http://oss.sgi.com/projects/FreeB/</a>.</p><h2>See Also</h2> <p><a href="glEnable.html"><code><strong>glEnable</strong></code></a></p></body>
</html>
